<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Snack Packz — 3D Forest</title>
  <meta name="theme-color" content="#050705"/>

  <style>
    :root{
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --dim:rgba(255,255,255,.52);
      --accent:rgba(205,255,140,.92);
      --ease:cubic-bezier(.16,1,.3,1);
      --shadow: 0 30px 110px rgba(0,0,0,.70);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:#030403;
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    /* Fullscreen 3D canvas */
    #stage{
      position:fixed;
      inset:0;
      z-index:0;
      background:#020302;
    }

    /* Top bar */
    #topbar{
      position:fixed; left:18px; right:18px; top:16px;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      z-index:50;
      user-select:none;
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .seed{
      width:10px; height:10px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
    }
    .brand b{ font-weight:950; letter-spacing:.2px; }
    .brand small{ display:block; color:var(--dim); font-weight:700; margin-top:2px; }

    .controls{ display:flex; gap:10px; align-items:center; }
    .pill{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--fg);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:900;
      cursor:pointer;
      text-decoration:none;
      user-select:none;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
      white-space:nowrap;
    }
    .pill:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.20); }
    .pill.cta{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.30); }

    /* Center hint */
    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      top: 94px;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      display:flex; gap:10px; align-items:center;
      user-select:none;
      z-index:50;
    }
    #hint .k{ font-weight:950; }
    #hint .s{ color:var(--muted); font-weight:800; }

    /* Bottom dock */
    #dock{
      position:fixed; left:18px; right:18px; bottom:16px;
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      user-select:none;
      z-index:50;
    }
    .chips{ display:flex; gap:10px; align-items:center; }
    .chip{
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.76);
      font-weight:900;
      font-size:12px;
      white-space:nowrap;
    }

    /* Crosshair */
    #crosshair{
      position:fixed; left:50%; top:50%;
      width:10px; height:10px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: rgba(255,255,255,.78);
      box-shadow: 0 0 0 10px rgba(255,255,255,.05);
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:60;
    }

    /* Minimap */
    #minimapHUD{
      position: fixed;
      right: 18px;
      bottom: 86px;
      width: 240px;
      border-radius: 22px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      padding: 10px;
      z-index: 60;
      user-select: none;
    }
    #minimapHUD .mmTop{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      padding: 4px 6px 8px;
    }
    #minimapHUD .mmTop b{ letter-spacing:.9px; font-weight:950; }
    #minimapHUD .mmHint{ color: rgba(255,255,255,.62); font-weight:850; font-size: 11px; }
    #minimapHUD canvas{
      width: 220px; height: 220px;
      display:block;
      border-radius: 18px;
    }
    #minimapHUD .mmBottom{
      display:flex; gap:8px; flex-wrap:wrap;
      padding: 8px 6px 2px;
    }
    #minimapHUD .mmChip{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding: 7px 10px;
      font-weight:900;
      font-size: 12px;
      color: rgba(255,255,255,.78);
    }

    /* Pause menu */
    #menu{
      position:fixed; inset:0; z-index:80;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding:18px;
    }
    #menuCard{
      width:min(520px, 94vw);
      border-radius:26px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      padding:16px;
    }
    #menuCard h2{ margin:6px 6px 10px; font-size:18px; letter-spacing:.2px; }
    #menuCard p{ margin:0 6px 14px; color: rgba(255,255,255,.70); font-weight:750; line-height:1.3; }
    .menuRow{ display:flex; gap:10px; flex-wrap:wrap; padding:6px; }
    .menuBtn{
      flex:1; min-width: 140px;
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding:12px 12px;
      background: rgba(255,255,255,.08);
      color: var(--fg);
      font-weight:950;
      cursor:pointer;
    }
    .menuBtn.primary{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.25); }

    /* Mobile controls */
    #mobileUI{
      position:fixed; left:0; right:0; bottom:0;
      padding:18px;
      display:none;
      justify-content:space-between;
      align-items:flex-end;
      gap:14px;
      z-index:90;
      pointer-events:none;
    }
    #joy{
      width:140px; height:140px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      position:relative;
      pointer-events:auto;
      touch-action:none;
    }
    #joyKnob{
      width:56px; height:56px;
      border-radius:999px;
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,.86);
      box-shadow: 0 18px 70px rgba(255,255,255,.12);
    }
    #useBtn{
      pointer-events:auto;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.90);
      color:#070a08;
      font-weight:950;
      border-radius: 18px;
      padding:16px 18px;
      min-width: 110px;
    }

    @media (pointer:coarse), (max-width: 820px){
      #mobileUI{ display:flex; }
      #minimapHUD{ display:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>

  <header id="topbar">
    <div class="brand">
      <span class="seed"></span>
      <div>
        <b>Snack Packz</b>
        <small>Click to lock • WASD move • Q/E turn • F enter • Esc menu</small>
      </div>
    </div>
    <div class="controls">
      <button id="exitBtn" class="pill" type="button">Exit</button>
      <button id="qualityBtn" class="pill" type="button" aria-pressed="true">Quality: Ultra</button>
      <a class="pill cta" href="shop.html">Order</a>
    </div>
  </header>

  <div id="hint">
    <div class="k">Click to lock</div>
    <div class="s">Move in 3D. Walk to a totem. Press F.</div>
  </div>

  <div id="dock">
    <div>
      <b id="dockTitle">Forest Clearing</b><br/>
      <small id="dockSub" style="color:rgba(255,255,255,.72);font-weight:750;">Find a totem.</small>
    </div>
    <div class="chips">
      <span class="chip" id="fpsChip">FPS: --</span>
      <span class="chip" id="stateChip">Click to lock</span>
    </div>
  </div>

  <div id="crosshair"></div>

  <div id="minimapHUD" aria-hidden="true">
    <div class="mmTop">
      <b>MAP</b>
      <span class="mmHint">Clearing boundaries.</span>
    </div>
    <canvas id="mm" width="220" height="220"></canvas>
    <div class="mmBottom">
      <span class="mmChip" id="mmPos">x 0.0 • z 0.0</span>
      <span class="mmChip" id="mmNear">Nearest: —</span>
    </div>
  </div>

  <div id="mobileUI" aria-hidden="true">
    <div id="joy"><div id="joyKnob"></div></div>
    <button id="useBtn" type="button">USE</button>
  </div>

  <div id="menu" aria-hidden="true">
    <div id="menuCard">
      <h2>Pause Menu</h2>
      <p>Resume, reset, or leave the forest.</p>
      <div class="menuRow">
        <button id="resumeBtn" class="menuBtn primary" type="button">Resume</button>
        <button id="resetBtn" class="menuBtn" type="button">Reset position</button>
        <button id="leaveBtn" class="menuBtn" type="button">Leave game</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

    // ===== Packs =====
    const PACKS = [
      { key:"fresh",  name:"FRESH",   tag:"Clean energy. Zero noise.",        page:"fresh.html",   poster:"assets/fresh.jpg",   video:"assets/fresh.mp4" },
      { key:"gaming", name:"GAMING",  tag:"Locked focus. Long sessions.",      page:"gaming.html",  poster:"assets/gaming.jpg",  video:"assets/gaming.mp4" },
      { key:"gym",    name:"GYM",     tag:"Explosive drive. Controlled burn.", page:"gym.html",     poster:"assets/gym.jpg",     video:"assets/gym.mp4" },
      { key:"work",   name:"WORK",    tag:"Calm clarity. Get it done.",        page:"work.html",    poster:"assets/work.jpg",    video:"assets/work.mp4" },
      { key:"lockin", name:"LOCK-IN", tag:"Tunnel vision. No distractions.",   page:"lock-in.html", poster:"assets/lockin.jpg",  video:"assets/lockin.mp4" }
    ];

    // ===== UI refs =====
    const canvas = document.getElementById("stage");
    const exitBtn = document.getElementById("exitBtn");
    const qualityBtn = document.getElementById("qualityBtn");
    const dockTitle = document.getElementById("dockTitle");
    const dockSub = document.getElementById("dockSub");
    const fpsChip = document.getElementById("fpsChip");
    const stateChip = document.getElementById("stateChip");

    const menu = document.getElementById("menu");
    const resumeBtn = document.getElementById("resumeBtn");
    const resetBtn = document.getElementById("resetBtn");
    const leaveBtn = document.getElementById("leaveBtn");

    const mm = document.getElementById("mm");
    const mmCtx = mm.getContext("2d");
    const mmPos = document.getElementById("mmPos");
    const mmNear = document.getElementById("mmNear");

    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const reduce = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;
    const mobile = coarse || innerWidth < 820;

    const joy = document.getElementById("joy");
    const joyKnob = document.getElementById("joyKnob");
    const useBtn = document.getElementById("useBtn");
    document.getElementById("mobileUI").style.display = mobile ? "flex" : "none";

    // ===== Quality =====
    const QUALITY = {
      ultra: !mobile && !reduce,
      set(v){
        this.ultra = v;
        qualityBtn.setAttribute("aria-pressed", String(v));
        qualityBtn.textContent = `Quality: ${v ? "Ultra" : "Lite"}`;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, v ? 2 : 1.25));
        fogNear = v ? 26 : 18;
        fogFar  = v ? 78 : 54;
        scene.fog.near = fogNear;
        scene.fog.far  = fogFar;
      }
    };

    // ===== World bounds (so you can't get lost) =====
    const BOUNDS = { minX:-45, maxX:45, minZ:-70, maxZ:20 };

    // ===== Noise (fast, deterministic) =====
    function hash2(x,z){
      // small hash for terrain. stable.
      let n = x * 374761393 + z * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }
    function smoothstep(t){ return t*t*(3-2*t); }
    function valueNoise(x,z){
      const xi = Math.floor(x), zi = Math.floor(z);
      const xf = x - xi, zf = z - zi;
      const a = hash2(xi,zi);
      const b = hash2(xi+1,zi);
      const c = hash2(xi,zi+1);
      const d = hash2(xi+1,zi+1);
      const u = smoothstep(xf);
      const v = smoothstep(zf);
      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return ab + (cd-ab)*v;
    }
    function fbm(x,z){
      let f=0, amp=1, freq=0.04;
      for(let i=0;i<5;i++){
        f += (valueNoise(x*freq, z*freq)-0.5)*2 * amp;
        amp *= 0.55;
        freq *= 2.0;
      }
      return f;
    }
    function heightAt(x,z){
      // "clearing" centre is flatter, edges more rough
      const base = fbm(x,z);
      const r = Math.sqrt(x*x + (z+16)*(z+16));
      const clearing = Math.max(0, 1 - (r/42));
      const flat = base * (1 - clearing*0.85);
      const micro = fbm(x*1.9, z*1.9) * 0.15;
      return flat*4.2 + micro;
    }

    // ===== Three.js Setup =====
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha:false });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, QUALITY.ultra ? 2 : 1.25));
    renderer.setClearColor(0x020302, 1);

    const scene = new THREE.Scene();
    let fogNear = QUALITY.ultra ? 26 : 18;
    let fogFar  = QUALITY.ultra ? 78 : 54;
    scene.fog = new THREE.Fog(0x050705, fogNear, fogFar);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 300);
    camera.position.set(0, 2.2, 0);

    const controls = new PointerLockControls(camera, document.body);
    const clock = new THREE.Clock();

    // Lighting
    const hemi = new THREE.HemisphereLight(0xbfe7c0, 0x0b0d0b, 0.75);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 0.70);
    sun.position.set(-12, 18, 10);
    scene.add(sun);

    // Skybox: big foggy dome (cheap but looks deep)
    const skyGeo = new THREE.SphereGeometry(160, 32, 24);
    const skyMat = new THREE.MeshBasicMaterial({
      color: 0x0a120a,
      side: THREE.BackSide
    });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // ===== Terrain =====
    const size = 160;
    const seg = QUALITY.ultra ? 220 : 140;
    const terrainGeo = new THREE.PlaneGeometry(size, size, seg, seg);
    terrainGeo.rotateX(-Math.PI/2);

    const pos = terrainGeo.attributes.position;
    const colors = [];
    for(let i=0;i<pos.count;i++){
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const h = heightAt(x,z);
      pos.setY(i, h);

      // vertex colour blend (mossy greens + dark)
      const moss = THREE.MathUtils.clamp((h+2)/6, 0, 1);
      const shade = THREE.MathUtils.clamp(0.55 + moss*0.45, 0, 1);
      const g = 0.18 + shade*0.55;
      const r = 0.10 + shade*0.22;
      const b = 0.10 + shade*0.18;
      colors.push(r,g,b);
    }
    terrainGeo.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));
    terrainGeo.computeVertexNormals();

    const terrainMat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 1.0,
      metalness: 0.0
    });

    const terrain = new THREE.Mesh(terrainGeo, terrainMat);
    terrain.receiveShadow = false;
    scene.add(terrain);

    // ===== Trees (instanced) =====
    const treeCount = QUALITY.ultra ? 1200 : 650;
    const trunkGeo = new THREE.CylinderGeometry(0.10, 0.16, 2.2, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x2a1b12, roughness: 1.0 });

    const leafGeo = new THREE.ConeGeometry(0.9, 2.6, 7);
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x0b2a12, roughness: 1.0 });

    const trunks = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
    const leaves = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

    const dummy = new THREE.Object3D();
    const treeColliders = []; // simple circles so you can't walk through nearby trees
    function inClearing(x,z){
      const r = Math.sqrt(x*x + (z+16)*(z+16));
      return r < 26; // keep centre open
    }

    let ti=0;
    while(ti<treeCount){
      const x = THREE.MathUtils.randFloatSpread(120);
      const z = THREE.MathUtils.randFloatSpread(120);
      if(inClearing(x,z)) continue;

      const y = heightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.85, 1.65);

      dummy.position.set(x, y+1.1*s, z);
      dummy.rotation.y = THREE.MathUtils.randFloat(0, Math.PI*2);
      dummy.scale.set(s, s, s);
      dummy.updateMatrix();
      trunks.setMatrixAt(ti, dummy.matrix);

      dummy.position.set(x, y+2.55*s, z);
      dummy.scale.set(s, s, s);
      dummy.updateMatrix();
      leaves.setMatrixAt(ti, dummy.matrix);

      // only store colliders for trees in playable range
      if(Math.abs(x) < 55 && z > -90 && z < 30){
        treeColliders.push({x, z, r: 0.65*s});
      }

      ti++;
    }

    scene.add(trunks, leaves);

    // ===== Totems (real 3D, clickable + F enter) =====
    const loader = new THREE.TextureLoader();
    const totems = [];

    function makeTotemCard(p, i, x, z){
      const group = new THREE.Group();
      const y = heightAt(x,z);

      group.position.set(x, y+1.7, z);

      // frame
      const frameGeo = new THREE.BoxGeometry(2.0, 2.8, 0.10);
      const frameMat = new THREE.MeshStandardMaterial({
        color: 0x0c0f0c,
        roughness: 0.55,
        metalness: 0.0
      });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      frame.position.set(0, 0, 0);
      group.add(frame);

      // screen plane
      const screenGeo = new THREE.PlaneGeometry(1.75, 2.45);
      const posterTex = loader.load(p.poster);
      posterTex.colorSpace = THREE.SRGBColorSpace;
      const screenMat = new THREE.MeshStandardMaterial({
        map: posterTex,
        roughness: 0.85,
        metalness: 0.0,
        emissive: new THREE.Color(0x0c1a0c),
        emissiveIntensity: 0.35
      });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, 0, 0.056);
      group.add(screen);

      // glow ring
      const ringGeo = new THREE.TorusGeometry(0.32, 0.06, 10, 22);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0xcfff8c });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.position.set(-0.68, 1.08, 0.08);
      group.add(ring);

      // title (canvas texture)
      const titleCanvas = document.createElement("canvas");
      titleCanvas.width = 512;
      titleCanvas.height = 256;
      const tctx = titleCanvas.getContext("2d");
      function drawTitle(active=false){
        tctx.clearRect(0,0,512,256);
        // glass
        tctx.fillStyle = "rgba(0,0,0,0.45)";
        roundRect(tctx, 16, 18, 480, 220, 26);
        tctx.fill();

        // border
        tctx.strokeStyle = active ? "rgba(205,255,140,0.85)" : "rgba(255,255,255,0.16)";
        tctx.lineWidth = 4;
        roundRect(tctx, 16, 18, 480, 220, 26);
        tctx.stroke();

        tctx.fillStyle = active ? "rgba(205,255,140,0.92)" : "rgba(255,255,255,0.92)";
        tctx.font = "900 48px system-ui, -apple-system, Segoe UI, Roboto";
        tctx.fillText(p.name, 46, 96);

        tctx.fillStyle = "rgba(255,255,255,0.72)";
        tctx.font = "800 22px system-ui, -apple-system, Segoe UI, Roboto";
        wrapText(tctx, p.tag, 46, 132, 420, 28);

        tctx.fillStyle = "rgba(255,255,255,0.78)";
        tctx.font = "900 20px system-ui, -apple-system, Segoe UI, Roboto";
        tctx.fillText("Walk closer • Press F", 46, 212);
      }
      function roundRect(ctx,x,y,w,h,r){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr, y);
        ctx.arcTo(x+w, y, x+w, y+h, rr);
        ctx.arcTo(x+w, y+h, x, y+h, rr);
        ctx.arcTo(x, y+h, x, y, rr);
        ctx.arcTo(x, y, x+w, y, rr);
        ctx.closePath();
      }
      function wrapText(ctx, text, x, y, maxWidth, lineHeight){
        const words = text.split(" ");
        let line = "";
        for(let n=0;n<words.length;n++){
          const test = line + words[n] + " ";
          const metrics = ctx.measureText(test);
          if(metrics.width > maxWidth && n > 0){
            ctx.fillText(line, x, y);
            line = words[n] + " ";
            y += lineHeight;
          } else {
            line = test;
          }
        }
        ctx.fillText(line, x, y);
      }
      drawTitle(false);

      const titleTex = new THREE.CanvasTexture(titleCanvas);
      titleTex.colorSpace = THREE.SRGBColorSpace;
      const titleMat = new THREE.MeshBasicMaterial({ map: titleTex, transparent:true });
      const titlePlane = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 1.05), titleMat);
      titlePlane.position.set(0, -1.7, 0.06);
      group.add(titlePlane);

      // store
      totems.push({
        p, i,
        group, screen, screenMat,
        titleCanvas, titleTex, drawTitle,
        x, z
      });

      scene.add(group);
    }

    // Place totems in a ring around the clearing
    const totemPositions = [
      {x:-12, z:-22},
      {x: 12, z:-22},
      {x:-8,  z:-34},
      {x:  8, z:-34},
      {x:  0, z:-28}
    ];
    PACKS.forEach((p,i)=> makeTotemCard(p,i, totemPositions[i].x, totemPositions[i].z));

    // ===== Controls / movement =====
    const keys = {w:false,a:false,s:false,d:false,q:false,e:false,shift:false};
    addEventListener("keydown",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="q") keys.q=true;
      if(k==="e") keys.e=true;
      if(k==="shift") keys.shift=true;

      if(k==="f") tryEnterFocused();
      if(k==="escape") openMenu();
      if(k==="r") resetPosition();
    });
    addEventListener("keyup",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="q") keys.q=false;
      if(k==="e") keys.e=false;
      if(k==="shift") keys.shift=false;
    });

    // Mobile joystick
    const joyState = {active:false,id:null,cx:0,cy:0,dx:0,dy:0};
    if(joy){
      joy.addEventListener("pointerdown",(e)=>{
        joyState.active=true; joyState.id=e.pointerId;
        joy.setPointerCapture(e.pointerId);
        const r=joy.getBoundingClientRect();
        joyState.cx=r.left+r.width/2; joyState.cy=r.top+r.height/2;
      });
      joy.addEventListener("pointermove",(e)=>{
        if(!joyState.active || e.pointerId!==joyState.id) return;
        const max=46;
        let dx=e.clientX-joyState.cx, dy=e.clientY-joyState.cy;
        const len=Math.hypot(dx,dy)||1;
        if(len>max){ dx=dx/len*max; dy=dy/len*max; }
        joyState.dx=dx/max; joyState.dy=dy/max;
        joyKnob.style.transform=`translate(${dx}px,${dy}px) translate(-50%,-50%)`;
      });
      const end=()=>{
        joyState.active=false; joyState.dx=0; joyState.dy=0;
        joyKnob.style.transform="translate(-50%,-50%)";
      };
      joy.addEventListener("pointerup",end);
      joy.addEventListener("pointercancel",end);
    }

    // Mobile look
    let look = {on:false,x:0,y:0};
    addEventListener("pointerdown",(e)=>{
      if(!mobile) return;
      if(e.target===joy || e.target===joyKnob || e.target===useBtn) return;
      look.on=true; look.x=e.clientX; look.y=e.clientY;
    },{passive:true});
    addEventListener("pointermove",(e)=>{
      if(!mobile || !look.on) return;
      const dx=e.clientX-look.x, dy=e.clientY-look.y;
      look.x=e.clientX; look.y=e.clientY;
      camera.rotation.y -= dx*0.0030;
      camera.rotation.x -= dy*0.0020;
      camera.rotation.x = THREE.MathUtils.clamp(camera.rotation.x, -0.75, 0.55);
    },{passive:true});
    addEventListener("pointerup",()=>{ look.on=false; },{passive:true});
    useBtn.addEventListener("click", tryEnterFocused);

    // Pointer lock entry
    addEventListener("click",(e)=>{
      const t=e.target;
      if(t.closest && (t.closest("#topbar") || t.closest("#dock") || t.closest("#minimapHUD") || t.closest("#menu") || t.closest("#mobileUI"))) return;
      if(!mobile) controls.lock();
    });

    controls.addEventListener("lock", ()=> stateChip.textContent = "WASD • Q/E • F");
    controls.addEventListener("unlock", ()=> stateChip.textContent = "Click to lock");

    // ===== Menu =====
    function openMenu(){
      menu.style.display="flex";
      try{ controls.unlock(); }catch{}
    }
    function closeMenu(){
      menu.style.display="none";
      if(!mobile) controls.lock();
    }
    exitBtn.addEventListener("click", openMenu);
    resumeBtn.addEventListener("click", closeMenu);
    resetBtn.addEventListener("click", ()=>{ resetPosition(); closeMenu(); });
    leaveBtn.addEventListener("click", ()=>{ location.href="shop.html"; });

    // ===== Focus / interaction (raycast) =====
    const raycaster = new THREE.Raycaster();
    let focused = -1;

    function updateFocus(){
      focused = -1;
      // ray from centre
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const objects = totems.map(t=>t.screen); // screen planes only
      const hits = raycaster.intersectObjects(objects, false);
      if(hits.length){
        const hit = hits[0].object;
        const idx = objects.indexOf(hit);
        if(idx >= 0) focused = idx;
      }
    }

    function tryEnterFocused(){
      if(focused < 0) return;
      const t = totems[focused];
      const dx = camera.position.x - t.x;
      const dz = camera.position.z - t.z;
      const d = Math.hypot(dx,dz);
      if(d < 4.2){
        location.href = t.p.page;
      } else {
        dockSub.textContent = `Walk closer (${d.toFixed(1)}m)`;
      }
    }

    // ===== Physics-ish =====
    const velocity = new THREE.Vector3();
    const dir = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0);

    function clampBounds(pos){
      pos.x = THREE.MathUtils.clamp(pos.x, BOUNDS.minX, BOUNDS.maxX);
      pos.z = THREE.MathUtils.clamp(pos.z, BOUNDS.minZ, BOUNDS.maxZ);
    }

    function resolveTreeCollisions(pos){
      // gentle push out of tree circles
      for(let i=0;i<treeColliders.length;i++){
        const c = treeColliders[i];
        const dx = pos.x - c.x;
        const dz = pos.z - c.z;
        const d = Math.hypot(dx,dz);
        const R = c.r;
        if(d > 0.0001 && d < R){
          const push = (R - d);
          pos.x += (dx / d) * push;
          pos.z += (dz / d) * push;
        }
      }
    }

    function snapToGround(pos){
      const h = heightAt(pos.x, pos.z);
      pos.y = h + 2.2; // camera height
    }

    // ===== Start position =====
    function resetPosition(){
      camera.position.set(0, heightAt(0,0)+2.2, 0);
      velocity.set(0,0,0);
      dockTitle.textContent = "Forest Clearing";
      dockSub.textContent = "Find a totem.";
    }
    resetPosition();

    // ===== Minimap =====
    function mmWorldToMap(wx,wz){
      const nx = (wx - BOUNDS.minX) / (BOUNDS.maxX - BOUNDS.minX);
      const nz = (wz - BOUNDS.minZ) / (BOUNDS.maxZ - BOUNDS.minZ);
      return { x:nx, y:nz };
    }
    function mmRoundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawMinimap(){
      if(mobile) return;
      const W=mm.width, H=mm.height;
      mmCtx.clearRect(0,0,W,H);

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(0,0,0,0.35)";
      mmRoundRect(mmCtx,0,0,W,H,18); mmCtx.fill();

      mmCtx.globalAlpha=.45;
      mmCtx.strokeStyle="rgba(255,255,255,0.10)";
      mmCtx.lineWidth=1;
      for(let i=1;i<5;i++){
        const x=(W*i/5)|0, y=(H*i/5)|0;
        mmCtx.beginPath(); mmCtx.moveTo(x,10); mmCtx.lineTo(x,H-10); mmCtx.stroke();
        mmCtx.beginPath(); mmCtx.moveTo(10,y); mmCtx.lineTo(W-10,y); mmCtx.stroke();
      }

      mmCtx.globalAlpha=1;
      mmCtx.strokeStyle="rgba(255,255,255,0.18)";
      mmCtx.lineWidth=1;
      mmRoundRect(mmCtx,0.5,0.5,W-1,H-1,18); mmCtx.stroke();

      const pad=18;

      // totems
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const m=mmWorldToMap(t.x, t.z);
        const x=pad + m.x*(W-2*pad);
        const y=pad + m.y*(H-2*pad);
        const isFocus = (i===focused);

        mmCtx.globalAlpha=isFocus?1:0.85;
        mmCtx.beginPath();
        mmCtx.strokeStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.55)";
        mmCtx.lineWidth=isFocus?3:2;
        mmCtx.arc(x,y,8,0,Math.PI*2); mmCtx.stroke();

        mmCtx.beginPath();
        mmCtx.fillStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.65)";
        mmCtx.arc(x,y,2.6,0,Math.PI*2); mmCtx.fill();
      }

      // player
      const mp=mmWorldToMap(camera.position.x, camera.position.z);
      const px=pad + mp.x*(W-2*pad);
      const py=pad + mp.y*(H-2*pad);

      mmCtx.globalAlpha=0.55;
      mmCtx.fillStyle="rgba(205,255,140,0.35)";
      mmCtx.beginPath(); mmCtx.arc(px,py,14,0,Math.PI*2); mmCtx.fill();

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(255,255,255,0.92)";
      mmCtx.beginPath(); mmCtx.arc(px,py,4.2,0,Math.PI*2); mmCtx.fill();

      // facing
      const ang = camera.rotation.y - Math.PI/2;
      mmCtx.strokeStyle="rgba(255,255,255,0.80)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.moveTo(px,py);
      mmCtx.lineTo(px + Math.cos(ang)*18, py + Math.sin(ang)*18);
      mmCtx.stroke();

      mmPos.textContent = `x ${camera.position.x.toFixed(1)} • z ${camera.position.z.toFixed(1)}`;

      // nearest
      let best={i:-1,d:1e9};
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const d=Math.hypot(t.x-camera.position.x, t.z-camera.position.z);
        if(d<best.d) best={i,d};
      }
      mmNear.textContent = best.i>=0 ? `Nearest: ${PACKS[best.i].name} (${best.d.toFixed(1)}m)` : "Nearest: —";
    }

    // ===== Billboard behaviour (totems face you) =====
    function faceTotems(){
      for(const t of totems){
        t.group.lookAt(camera.position.x, t.group.position.y, camera.position.z);
      }
    }

    // ===== Update UI for focused totem =====
    function updateTotemUI(){
      dockTitle.textContent = focused >= 0 ? PACKS[focused].name : "Forest Clearing";
      if(focused >= 0){
        const t = totems[focused];
        const d = Math.hypot(camera.position.x - t.x, camera.position.z - t.z);
        dockSub.textContent = d < 4.2 ? "Press F to enter" : `Walk closer (${d.toFixed(1)}m)`;
      } else {
        dockSub.textContent = "Find a totem.";
      }

      for(let i=0;i<totems.length;i++){
        const tt = totems[i];
        const isFocus = (i===focused);
        tt.drawTitle(isFocus);
        tt.titleTex.needsUpdate = true;
      }
    }

    // ===== Resize =====
    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    }, {passive:true});

    // ===== Quality button =====
    qualityBtn.addEventListener("click", ()=>{
      QUALITY.set(!QUALITY.ultra);
    });
    QUALITY.set(QUALITY.ultra);

    // ===== Main loop =====
    let frames=0, fpsLast=performance.now();

    function animate(){
      requestAnimationFrame(animate);

      const dt = Math.min(0.033, clock.getDelta()); // cap dt

      // Q/E turn (extra, on top of mouse look)
      if(keys.q) camera.rotation.y += 1.25 * dt;
      if(keys.e) camera.rotation.y -= 1.25 * dt;

      // Movement vector
      dir.set(0,0,0);
      const sp = (keys.shift ? 6.2 : 4.7) * (mobile ? 0.85 : 1);

      if(keys.w) dir.z -= 1;
      if(keys.s) dir.z += 1;
      if(keys.a) dir.x -= 1;
      if(keys.d) dir.x += 1;

      if(mobile){
        dir.x += joyState.dx;
        dir.z += joyState.dy;
      }

      if(dir.lengthSq() > 0) dir.normalize();

      // Convert local movement to world direction
      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      const right = new THREE.Vector3().crossVectors(forward, up).normalize().negate();

      const move = new THREE.Vector3()
        .addScaledVector(forward, dir.z)
        .addScaledVector(right, dir.x);

      // Apply
      camera.position.addScaledVector(move, sp * dt);

      // Boundaries + collisions + ground snap
      clampBounds(camera.position);
      resolveTreeCollisions(camera.position);
      snapToGround(camera.position);

      // Keep sky centred
      sky.position.copy(camera.position);

      // Totems face you
      faceTotems();

      // Focus & UI
      updateFocus();
      updateTotemUI();

      // Render
      renderer.render(scene, camera);

      // Minimap
      drawMinimap();

      // FPS
      frames++;
      const now=performance.now();
      if(now - fpsLast > 500){
        fpsChip.textContent = `FPS: ${Math.round(frames*1000/(now-fpsLast))}`;
        frames=0; fpsLast=now;
      }
    }

    // Start
    animate();

  </script>
</body>
</html>
