<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
  <title>Snack Packz — Forest Portal</title>
  <meta name="theme-color" content="#050705"/>

  <!-- ✅ FIX: Import Map so "three" specifier works on GitHub Pages -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root{
      --fg: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --dim: rgba(255,255,255,.55);
      --glass: rgba(0,0,0,.26);
      --glass2: rgba(0,0,0,.18);
      --stroke: rgba(255,255,255,.12);
      --stroke2: rgba(255,255,255,.10);
      --accent: rgba(205,255,140,.92);
      --shadow: 0 30px 110px rgba(0,0,0,.70);
      --ease: cubic-bezier(.16,1,.3,1);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; overflow:hidden; background:#020302; color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    #stage{position:fixed;inset:0;z-index:0;background:#020302}

    #topbar{
      position:fixed;left:18px;right:18px;top:16px;
      display:flex;align-items:center;justify-content:space-between;
      padding:12px 14px;border-radius:999px;
      background:var(--glass);border:1px solid var(--stroke);
      backdrop-filter: blur(14px);
      box-shadow:var(--shadow);
      z-index:50;user-select:none;
    }
    .brand{display:flex;gap:10px;align-items:center}
    .seed{
      width:10px;height:10px;border-radius:999px;
      background:radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
      flex:0 0 auto;
    }
    .brand b{font-weight:950;letter-spacing:.2px}
    .brand small{
      display:block;color:var(--dim);font-weight:750;margin-top:2px;
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
      max-width:min(62vw,720px)
    }
    .controls{display:flex;gap:10px;align-items:center}
    .pill{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.24);
      color:var(--fg);
      padding:10px 12px;border-radius:999px;
      font-weight:900;cursor:pointer;text-decoration:none;
      user-select:none;
      transition:transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease), opacity .25s var(--ease);
      white-space:nowrap;
    }
    .pill:hover{transform:translateY(-1px);background:rgba(255,255,255,.06);border-color:rgba(255,255,255,.20)}
    .pill.cta{background:rgba(255,255,255,.92);color:#070a08;border-color:rgba(255,255,255,.28)}
    .pill.danger{background:rgba(255,90,90,.14);border-color:rgba(255,90,90,.35)}
    .pill[aria-pressed="false"]{opacity:.78}

    #hint{
      position:fixed;left:50%;transform:translateX(-50%);
      top:94px;z-index:50;user-select:none;
      padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.22);
      border:1px solid var(--stroke2);
      backdrop-filter: blur(12px);
      display:flex;gap:10px;align-items:center;
    }
    #hint .k{font-weight:950}
    #hint .s{color:var(--muted);font-weight:800}

    #dock{
      position:fixed;left:18px;right:18px;bottom:16px;
      display:flex;justify-content:space-between;align-items:center;
      padding:12px 14px;border-radius:999px;
      background:var(--glass);border:1px solid var(--stroke2);
      backdrop-filter: blur(14px);
      box-shadow:var(--shadow);
      user-select:none;z-index:50;
    }
    .chipRow{display:flex;gap:10px;align-items:center}
    .chip{
      padding:9px 12px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.20);
      color:rgba(255,255,255,.78);
      font-weight:900;font-size:12px;white-space:nowrap;
    }

    #crosshair{
      position:fixed;left:50%;top:50%;
      width:10px;height:10px;transform:translate(-50%,-50%);
      border-radius:999px;background:rgba(255,255,255,.80);
      box-shadow: 0 0 0 10px rgba(255,255,255,.05);
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:60;
    }

    #minimapHUD{
      position:fixed;right:18px;bottom:86px;width:260px;
      border-radius:22px;padding:10px;
      background:var(--glass2);border:1px solid var(--stroke2);
      backdrop-filter: blur(14px);
      box-shadow:var(--shadow);
      z-index:60;user-select:none;
    }
    #minimapHUD .mmTop{display:flex;justify-content:space-between;align-items:baseline;gap:10px;padding:4px 6px 8px}
    #minimapHUD .mmTop b{letter-spacing:.9px;font-weight:950}
    #minimapHUD .mmHint{color:rgba(255,255,255,.62);font-weight:850;font-size:11px}
    #minimapHUD canvas{width:240px;height:240px;display:block;border-radius:18px}
    #minimapHUD .mmBottom{display:flex;gap:8px;flex-wrap:wrap;padding:8px 6px 2px}
    #minimapHUD .mmChip{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.22);
      border-radius:999px;
      padding:7px 10px;
      font-weight:900;font-size:12px;
      color:rgba(255,255,255,.78);
    }

    #menu{
      position:fixed;inset:0;z-index:80;
      display:none;align-items:center;justify-content:center;
      background:rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding:18px;
    }
    #menuCard{
      width:min(560px, 94vw);
      border-radius:26px;
      background:rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      box-shadow:var(--shadow);
      padding:16px;
    }
    #menuCard h2{margin:6px 6px 10px;font-size:18px;letter-spacing:.2px}
    #menuCard p{margin:0 6px 14px;color:rgba(255,255,255,.74);font-weight:750;line-height:1.35}
    .menuRow{display:flex;gap:10px;flex-wrap:wrap;padding:6px}
    .menuBtn{
      flex:1;min-width:150px;
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:12px 12px;
      background:rgba(255,255,255,.08);
      color:var(--fg);
      font-weight:950;
      cursor:pointer;
    }
    .menuBtn.primary{background:rgba(255,255,255,.92);color:#070a08;border-color:rgba(255,255,255,.25)}
    .menuBtn.danger{background:rgba(255,90,90,.16);border-color:rgba(255,90,90,.35)}
    .menuFine{padding:2px 6px 8px;color:rgba(255,255,255,.62);font-weight:750;font-size:12px;line-height:1.35}

    #mobileUI{
      position:fixed;left:0;right:0;bottom:0;
      padding:18px;
      display:none;
      justify-content:space-between;
      align-items:flex-end;
      gap:14px;
      z-index:90;
      pointer-events:none;
    }
    #joy{
      width:140px;height:140px;border-radius:999px;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      position:relative;
      pointer-events:auto;
      touch-action:none;
    }
    #joyKnob{
      width:56px;height:56px;border-radius:999px;
      position:absolute;left:50%;top:50%;
      transform:translate(-50%,-50%);
      background:rgba(255,255,255,.88);
      box-shadow: 0 18px 70px rgba(255,255,255,.12);
    }
    #useBtn{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.92);
      color:#070a08;
      font-weight:950;
      border-radius:18px;
      padding:16px 18px;
      min-width: 118px;
    }

    @media (pointer:coarse), (max-width: 860px){
      #mobileUI{display:flex}
      #minimapHUD{display:none}
      .brand small{max-width:52vw}
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>

  <header id="topbar">
    <div class="brand">
      <span class="seed"></span>
      <div>
        <b>Snack Packz</b>
        <small id="subline">Click to lock • WASD move • Q/E turn • F enter • Esc menu</small>
      </div>
    </div>

    <div class="controls">
      <button id="soundBtn" class="pill" type="button" aria-pressed="false">Sound: Off</button>
      <button id="qualityBtn" class="pill" type="button" aria-pressed="true">Quality: Ultra</button>
      <button id="exitBtn" class="pill danger" type="button">Exit</button>
      <a class="pill cta" href="shop.html">Order</a>
    </div>
  </header>

  <div id="hint">
    <div class="k">Click to lock</div>
    <div class="s">Aim at a totem → it “wakes up”. Walk close → F enters.</div>
  </div>

  <div id="dock">
    <div>
      <b id="dockTitle">Forest Clearing</b><br/>
      <small id="dockSub" style="color:rgba(255,255,255,.72);font-weight:750;">Find a totem.</small>
    </div>
    <div class="chipRow">
      <span class="chip" id="fpsChip">FPS: --</span>
      <span class="chip" id="stateChip">Click to lock</span>
      <span class="chip" id="zoneChip">Zone: Clearing</span>
    </div>
  </div>

  <div id="crosshair"></div>

  <div id="minimapHUD" aria-hidden="true">
    <div class="mmTop">
      <b>MAP</b>
      <span class="mmHint" id="mmHint">Clearing + terrain</span>
    </div>
    <canvas id="mm" width="240" height="240"></canvas>
    <div class="mmBottom">
      <span class="mmChip" id="mmPos">x 0.0 • z 0.0</span>
      <span class="mmChip" id="mmNear">Nearest: —</span>
      <span class="mmChip" id="mmHead">N ↑</span>
    </div>
  </div>

  <div id="mobileUI" aria-hidden="true">
    <div id="joy"><div id="joyKnob"></div></div>
    <button id="useBtn" type="button">USE</button>
  </div>

  <div id="menu" aria-hidden="true">
    <div id="menuCard">
      <h2>Pause Menu</h2>
      <p>Resume, reset, or leave the forest.</p>
      <div class="menuRow">
        <button id="resumeBtn" class="menuBtn primary" type="button">Resume</button>
        <button id="resetBtn"  class="menuBtn" type="button">Reset to clearing</button>
        <button id="panicBtn"  class="menuBtn" type="button">Return to nearest totem</button>
        <button id="leaveBtn"  class="menuBtn danger" type="button">Leave game</button>
      </div>
      <div class="menuFine">
        Tip: If you ever feel lost, hit <b>Esc</b> → <b>Return to nearest totem</b>. You cannot soft-lock.
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { FilmPass } from "three/addons/postprocessing/FilmPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";
    import { VignetteShader } from "three/addons/shaders/VignetteShader.js";

    // ===== Packs =====
    const PACKS = [
      { key:"fresh",  name:"FRESH",   tag:"Clean energy. Zero noise.",        page:"fresh.html",   poster:"assets/fresh.jpg",   video:"assets/fresh.mp4" },
      { key:"gaming", name:"GAMING",  tag:"Locked focus. Long sessions.",      page:"gaming.html",  poster:"assets/gaming.jpg",  video:"assets/gaming.mp4" },
      { key:"gym",    name:"GYM",     tag:"Explosive drive. Controlled burn.", page:"gym.html",     poster:"assets/gym.jpg",     video:"assets/gym.mp4" },
      { key:"work",   name:"WORK",    tag:"Calm clarity. Get it done.",        page:"work.html",    poster:"assets/work.jpg",    video:"assets/work.mp4" },
      { key:"lockin", name:"LOCK-IN", tag:"Tunnel vision. No distractions.",   page:"lock-in.html", poster:"assets/lockin.jpg",  video:"assets/lockin.mp4" }
    ];

    // ===== UI =====
    const canvas = document.getElementById("stage");
    const qualityBtn = document.getElementById("qualityBtn");
    const soundBtn = document.getElementById("soundBtn");
    const exitBtn = document.getElementById("exitBtn");

    const dockTitle = document.getElementById("dockTitle");
    const dockSub   = document.getElementById("dockSub");
    const fpsChip   = document.getElementById("fpsChip");
    const stateChip = document.getElementById("stateChip");
    const zoneChip  = document.getElementById("zoneChip");

    const menu = document.getElementById("menu");
    const resumeBtn = document.getElementById("resumeBtn");
    const resetBtn  = document.getElementById("resetBtn");
    const panicBtn  = document.getElementById("panicBtn");
    const leaveBtn  = document.getElementById("leaveBtn");

    const mm = document.getElementById("mm");
    const mmCtx = mm.getContext("2d");
    const mmPos = document.getElementById("mmPos");
    const mmNear = document.getElementById("mmNear");
    const mmHead = document.getElementById("mmHead");
    const mmHint = document.getElementById("mmHint");

    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const reduce = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;
    const mobile = coarse || innerWidth < 860;

    const joy = document.getElementById("joy");
    const joyKnob = document.getElementById("joyKnob");
    const useBtn = document.getElementById("useBtn");
    document.getElementById("mobileUI").style.display = mobile ? "flex" : "none";

    // ===== Safety: crash overlay =====
    function crashBox(err){
      console.error(err);
      const box = document.createElement("div");
      box.style.cssText = `
        position:fixed;left:18px;top:120px;z-index:9999;max-width:min(720px,92vw);
        padding:14px 14px;border-radius:18px;
        background:rgba(90,0,0,.45);border:1px solid rgba(255,120,120,.40);
        color:rgba(255,255,255,.92);font-weight:850;backdrop-filter: blur(12px);
        box-shadow: 0 30px 110px rgba(0,0,0,.70);
      `;
      box.innerHTML = `<b>Crash reason</b><div style="margin-top:6px;color:rgba(255,255,255,.80);font-weight:750;line-height:1.35">${String(err).replaceAll("<","&lt;")}</div>`;
      document.body.appendChild(box);
    }
    window.addEventListener("error", (e)=> crashBox(e.error || e.message));
    window.addEventListener("unhandledrejection", (e)=> crashBox(e.reason || "Unhandled promise rejection"));

    // ===== World bounds =====
    const BOUNDS = { minX:-70, maxX:70, minZ:-140, maxZ:30 };
    const CLEARING = { x:0, z:0, r:34 };

    // ===== Noise / terrain =====
    function hash2(x,z){
      let n = x * 374761393 + z * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }
    function smoothstep(t){ return t*t*(3-2*t); }
    function valueNoise(x,z){
      const xi = Math.floor(x), zi = Math.floor(z);
      const xf = x - xi, zf = z - zi;
      const a = hash2(xi,zi), b = hash2(xi+1,zi), c = hash2(xi,zi+1), d = hash2(xi+1,zi+1);
      const u = smoothstep(xf), v = smoothstep(zf);
      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return ab + (cd-ab)*v;
    }
    function fbm(x,z){
      let f=0, amp=1, freq=0.04;
      for(let i=0;i<5;i++){
        f += (valueNoise(x*freq, z*freq)-0.5)*2 * amp;
        amp *= 0.55;
        freq *= 2.0;
      }
      return f;
    }
    function heightAt(x,z){
      const base = fbm(x,z);
      const r = Math.sqrt((x-CLEARING.x)**2 + (z-(CLEARING.z-18))**2);
      const clearing = Math.max(0, 1 - (r/52));
      const flat = base * (1 - clearing*0.92);
      const micro = fbm(x*1.9, z*1.9) * 0.14;
      return flat*5.0 + micro;
    }

    // ===== Three setup =====
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, powerPreference:"high-performance" });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, mobile ? 1.35 : 2));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x060806, mobile ? 34 : 42, mobile ? 130 : 170);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.08, 520);
    camera.position.set(0, 2.15, 0);

    const controls = new PointerLockControls(camera, document.body);

    // Lights
    scene.add(new THREE.HemisphereLight(0xdfffe0, 0x1b241b, 1.15));
    const sun = new THREE.DirectionalLight(0xffffff, 0.95);
    sun.position.set(-16, 22, 10);
    scene.add(sun);

    // Sky dome
    const skyVideo = document.createElement("video");
    skyVideo.src = "assets/forest.mp4";
    skyVideo.loop = true;
    skyVideo.muted = true;
    skyVideo.playsInline = true;
    skyVideo.preload = "auto";

    const skyTex = new THREE.VideoTexture(skyVideo);
    skyTex.colorSpace = THREE.SRGBColorSpace;
    skyTex.minFilter = THREE.LinearFilter;
    skyTex.magFilter = THREE.LinearFilter;

    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(280, 56, 36),
      new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide })
    );
    scene.add(sky);

    scene.add(new THREE.Mesh(
      new THREE.SphereGeometry(279, 30, 20),
      new THREE.MeshBasicMaterial({ color:0x070907, transparent:true, opacity:0.18, side:THREE.BackSide })
    ));

    // Terrain
    const terrainSize = 220;
    const seg = mobile ? 150 : 240;
    const terrainGeo = new THREE.PlaneGeometry(terrainSize, terrainSize, seg, seg);
    terrainGeo.rotateX(-Math.PI/2);

    const pos = terrainGeo.attributes.position;
    const cols = [];
    for(let i=0;i<pos.count;i++){
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const h = heightAt(x,z);
      pos.setY(i, h);

      const moss = THREE.MathUtils.clamp((h+2)/7, 0, 1);
      const shade = THREE.MathUtils.clamp(0.55 + moss*0.45, 0, 1);

      const g = 0.22 + shade*0.42;
      const r = 0.11 + shade*0.22;
      const b = 0.11 + shade*0.20;
      cols.push(r,g,b);
    }
    terrainGeo.setAttribute("color", new THREE.Float32BufferAttribute(cols, 3));
    terrainGeo.computeVertexNormals();

    scene.add(new THREE.Mesh(
      terrainGeo,
      new THREE.MeshStandardMaterial({ vertexColors:true, roughness:1.0, metalness:0.0 })
    ));

    // Post FX
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    const bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), 0.45, 0.35, 0.20);
    composer.addPass(bloomPass);

    const filmPass = new FilmPass(0.20, 0.35, 620, false);
    composer.addPass(filmPass);

    const vignettePass = new ShaderPass(VignetteShader);
    const vu = vignettePass.uniforms || vignettePass.material?.uniforms;
    if(vu?.offset)   vu.offset.value = 1.05;
    if(vu?.darkness) vu.darkness.value = 1.25;
    composer.addPass(vignettePass);

    // Quality toggle
    const QUALITY = {
      ultra: !mobile && !reduce,
      set(v){
        this.ultra = !!v;
        qualityBtn.setAttribute("aria-pressed", String(this.ultra));
        qualityBtn.textContent = `Quality: ${this.ultra ? "Ultra" : "Lite"}`;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, this.ultra ? 2 : (mobile ? 1.25 : 1.5)));
        scene.fog.near = this.ultra ? 42 : 34;
        scene.fog.far  = this.ultra ? 175 : 140;
        bloomPass.strength  = this.ultra ? 0.52 : 0.26;
        bloomPass.radius    = this.ultra ? 0.36 : 0.25;
        bloomPass.threshold = this.ultra ? 0.18 : 0.26;
        mmHint.textContent = this.ultra ? "Clearing + terrain (Ultra)" : "Clearing + terrain (Lite)";
      }
    };
    qualityBtn.addEventListener("click", ()=> QUALITY.set(!QUALITY.ultra));
    QUALITY.set(QUALITY.ultra);

    // Trees (instanced) + colliders
    const treeCount = QUALITY.ultra ? 1400 : 760;
    const trunkGeo = new THREE.CylinderGeometry(0.10, 0.16, 2.2, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color:0x2a1b12, roughness:1.0 });
    const leafGeo  = new THREE.ConeGeometry(0.9, 2.6, 7);
    const leafMat  = new THREE.MeshStandardMaterial({ color:0x0b2a12, roughness:1.0 });

    const trunks = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
    const leaves = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

    const dummy = new THREE.Object3D();
    const treeMeta = [];
    const treeColliders = [];

    function inClearing(x,z){
      const dx = x - CLEARING.x;
      const dz = z - (CLEARING.z-18);
      return Math.hypot(dx,dz) < (CLEARING.r - 4);
    }

    let ti=0;
    while(ti<treeCount){
      const x = THREE.MathUtils.randFloatSpread(160);
      const z = THREE.MathUtils.randFloatSpread(200) - 40;
      if(inClearing(x,z)) continue;
      if(x < BOUNDS.minX-10 || x > BOUNDS.maxX+10 || z < BOUNDS.minZ-10 || z > BOUNDS.maxZ+10) continue;

      const y = heightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.85, 1.70);
      const rot = THREE.MathUtils.randFloat(0, Math.PI*2);
      const phase = (x*0.11 + z*0.07);

      dummy.position.set(x, y + 1.1*s, z);
      dummy.rotation.set(0, rot, 0);
      dummy.scale.set(s,s,s);
      dummy.updateMatrix();
      trunks.setMatrixAt(ti, dummy.matrix);

      dummy.position.set(x, y + 2.55*s, z);
      dummy.rotation.set(0, rot, 0);
      dummy.scale.set(s,s,s);
      dummy.updateMatrix();
      leaves.setMatrixAt(ti, dummy.matrix);

      treeMeta[ti] = { x,z,s,rot,phase };

      if(Math.abs(x) < 80 && z > (BOUNDS.minZ-10) && z < (BOUNDS.maxZ+10)){
        treeColliders.push({ x,z, r: 0.70*s });
      }

      ti++;
    }
    scene.add(trunks, leaves);

    // Totems
    const loader = new THREE.TextureLoader();
    const totems = [];

    const packVideos = PACKS.map(p=>{
      const v = document.createElement("video");
      v.src = p.video;
      v.loop = true;
      v.muted = true;
      v.playsInline = true;
      v.preload = "auto";
      return v;
    });

    function makeTotem(p,i,x,z){
      const group = new THREE.Group();
      const y = heightAt(x,z);
      group.position.set(x, y + 1.85, z);

      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(2.08, 2.95, 0.14),
        new THREE.MeshStandardMaterial({ color:0x0c0f0c, roughness:0.55 })
      );
      group.add(frame);

      const posterTex = loader.load(p.poster);
      posterTex.colorSpace = THREE.SRGBColorSpace;

      const vidTex = new THREE.VideoTexture(packVideos[i]);
      vidTex.colorSpace = THREE.SRGBColorSpace;
      vidTex.minFilter = THREE.LinearFilter;
      vidTex.magFilter = THREE.LinearFilter;

      const screenMat = new THREE.MeshStandardMaterial({
        map: posterTex,
        roughness: 0.90,
        emissive: new THREE.Color(0x0c1a0c),
        emissiveIntensity: 0.34
      });

      const screen = new THREE.Mesh(new THREE.PlaneGeometry(1.80, 2.52), screenMat);
      screen.position.set(0,0,0.075);
      group.add(screen);

      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.34, 0.07, 10, 22),
        new THREE.MeshBasicMaterial({ color:0xcfff8c })
      );
      ring.position.set(-0.72, 1.12, 0.095);
      group.add(ring);

      const glow = new THREE.Mesh(
        new THREE.CircleGeometry(1.35, 28),
        new THREE.MeshBasicMaterial({ color:0xcfff8c, transparent:true, opacity:0.07 })
      );
      glow.rotateX(-Math.PI/2);
      glow.position.set(0, -1.85, 0);
      group.add(glow);

      scene.add(group);
      totems.push({ p,i,x,z, group, screen, screenMat, posterTex, vidTex, ring, glow, awake:0 });
    }

    const totemPositions = [
      {x:-16, z:-30},
      {x: 16, z:-30},
      {x:-10, z:-46},
      {x: 10, z:-46},
      {x:  0, z:-36}
    ];
    PACKS.forEach((p,i)=> makeTotem(p,i, totemPositions[i].x, totemPositions[i].z));

    // Input
    const keys = { w:false,a:false,s:false,d:false,q:false,e:false,shift:false };
    addEventListener("keydown",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k in keys) keys[k]=true;
      if(k==="f") tryEnterFocused();
      if(k==="escape") toggleMenu(true);
      if(k==="r") resetToClearing();
    });
    addEventListener("keyup",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k in keys) keys[k]=false;
    });

    // Mobile joystick
    const joyState = { active:false, id:null, cx:0, cy:0, dx:0, dy:0 };
    if(joy){
      joy.addEventListener("pointerdown",(e)=>{
        joyState.active=true; joyState.id=e.pointerId;
        joy.setPointerCapture(e.pointerId);
        const r=joy.getBoundingClientRect();
        joyState.cx=r.left+r.width/2; joyState.cy=r.top+r.height/2;
      });
      joy.addEventListener("pointermove",(e)=>{
        if(!joyState.active || e.pointerId!==joyState.id) return;
        const max=46;
        let dx=e.clientX-joyState.cx, dy=e.clientY-joyState.cy;
        const len=Math.hypot(dx,dy)||1;
        if(len>max){ dx=dx/len*max; dy=dy/len*max; }
        joyState.dx=dx/max; joyState.dy=dy/max;
        joyKnob.style.transform=`translate(${dx}px,${dy}px) translate(-50%,-50%)`;
      });
      const end=()=>{
        joyState.active=false; joyState.dx=0; joyState.dy=0;
        joyKnob.style.transform="translate(-50%,-50%)";
      };
      joy.addEventListener("pointerup",end);
      joy.addEventListener("pointercancel",end);
    }
    useBtn.addEventListener("click", tryEnterFocused);

    // Pointer lock + start media once
    let startedMedia=false;
    function startMediaOnce(){
      if(startedMedia) return;
      startedMedia=true;
      skyVideo.play().catch(()=>{});
      for(const v of packVideos) v.play().catch(()=>{});
    }
    addEventListener("click",(e)=>{
      const t=e.target;
      if(t.closest && (t.closest("#topbar")||t.closest("#dock")||t.closest("#minimapHUD")||t.closest("#menu")||t.closest("#mobileUI"))) return;
      if(!mobile) controls.lock();
      startMediaOnce();
    });

    controls.addEventListener("lock", ()=> stateChip.textContent = "WASD • Q/E • F");
    controls.addEventListener("unlock", ()=> stateChip.textContent = "Click to lock");

    // Menu
    function toggleMenu(open){
      menu.style.display = open ? "flex" : "none";
      if(open){ try{controls.unlock()}catch{} }
      else{ if(!mobile) controls.lock(); }
    }
    exitBtn.addEventListener("click", ()=> toggleMenu(true));
    resumeBtn.addEventListener("click", ()=> toggleMenu(false));
    leaveBtn.addEventListener("click", ()=> location.href="shop.html");

    // Movement (Steam feel)
    const clock = new THREE.Clock();
    const up = new THREE.Vector3(0,1,0);
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    const wish = new THREE.Vector3();
    const vel = new THREE.Vector3();
    let bob=0;
    let baseFov=72;

    function clampBoundsXZ(p){
      p.x = THREE.MathUtils.clamp(p.x, BOUNDS.minX, BOUNDS.maxX);
      p.z = THREE.MathUtils.clamp(p.z, BOUNDS.minZ, BOUNDS.maxZ);
    }
    function resolveTreeCollisions(p){
      for(const c of treeColliders){
        const dx=p.x-c.x, dz=p.z-c.z;
        const d=Math.hypot(dx,dz);
        if(d>0.0001 && d<c.r){
          const push=(c.r-d);
          p.x += (dx/d)*push;
          p.z += (dz/d)*push;
        }
      }
    }
    function snapToGround(p){
      p.y = heightAt(p.x,p.z) + 2.15;
    }
    function resetToClearing(){
      camera.position.set(CLEARING.x, heightAt(CLEARING.x,CLEARING.z)+2.15, CLEARING.z);
      vel.set(0,0,0);
      dockTitle.textContent="Forest Clearing";
      dockSub.textContent="Find a totem.";
    }
    function teleportToNearestTotem(){
      let best={i:-1,d:1e9};
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const d=Math.hypot(t.x-camera.position.x, t.z-camera.position.z);
        if(d<best.d) best={i,d};
      }
      if(best.i>=0){
        const t=totems[best.i];
        camera.position.set(t.x, heightAt(t.x,t.z)+2.15, t.z+4.6);
        vel.set(0,0,0);
      }else resetToClearing();
    }
    resetBtn.addEventListener("click", ()=>{ resetToClearing(); toggleMenu(false); });
    panicBtn.addEventListener("click", ()=>{ teleportToNearestTotem(); toggleMenu(false); });

    // Focus raycast
    const raycaster = new THREE.Raycaster();
    let focused=-1;
    function updateFocus(){
      focused=-1;
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const screens = totems.map(t=>t.screen);
      const hits = raycaster.intersectObjects(screens,false);
      if(hits.length){
        const idx = screens.indexOf(hits[0].object);
        if(idx>=0) focused=idx;
      }
    }
    function tryEnterFocused(){
      if(focused<0) return;
      const t=totems[focused];
      const d=Math.hypot(camera.position.x-t.x, camera.position.z-t.z);
      if(d<4.8) location.href=t.p.page;
      else dockSub.textContent=`Walk closer (${d.toFixed(1)}m)`;
    }

    // Totem update
    function updateTotems(time){
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        t.group.lookAt(camera.position.x, t.group.position.y, camera.position.z);
        const d=Math.hypot(camera.position.x-t.x, camera.position.z-t.z);
        const targetAwake = (i===focused || d<18) ? 1 : 0;
        t.awake += (targetAwake - t.awake) * 0.08;

        const pulse = 0.5 + 0.5*Math.sin(time*0.0016 + i);
        t.ring.scale.setScalar(1 + pulse*0.10 + t.awake*0.18);

        const heart = 0.5 + 0.5*Math.sin(time*0.0042);
        t.glow.material.opacity = 0.04 + t.awake*0.10 + (d<7 ? heart*0.05 : 0);

        if(i===focused){
          if(t.screenMat.map !== t.vidTex){ t.screenMat.map=t.vidTex; t.screenMat.needsUpdate=true; }
          t.screenMat.emissiveIntensity = 0.58;
        }else{
          if(t.screenMat.map !== t.posterTex){ t.screenMat.map=t.posterTex; t.screenMat.needsUpdate=true; }
          t.screenMat.emissiveIntensity = 0.34 + t.awake*0.08;
        }
      }
    }

    // Minimap
    function mmRoundRect(ctx,x,y,w,h,r){
      const rr=Math.min(r,w/2,h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr,y);
      ctx.arcTo(x+w,y,x+w,y+h,rr);
      ctx.arcTo(x+w,y+h,x,y+h,rr);
      ctx.arcTo(x,y+h,x,y,rr);
      ctx.arcTo(x,y,x+w,y,rr);
      ctx.closePath();
    }
    function worldToMap(wx,wz){
      return {
        x:(wx-BOUNDS.minX)/(BOUNDS.maxX-BOUNDS.minX),
        y:(wz-BOUNDS.minZ)/(BOUNDS.maxZ-BOUNDS.minZ)
      };
    }
    function drawMinimap(){
      if(mobile) return;
      const W=mm.width,H=mm.height;
      mmCtx.clearRect(0,0,W,H);

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(0,0,0,0.35)";
      mmRoundRect(mmCtx,0,0,W,H,18); mmCtx.fill();

      const pad=16, innerW=W-2*pad, innerH=H-2*pad;
      const step = QUALITY.ultra ? 10 : 14;

      for(let y=0;y<innerH;y+=step){
        for(let x=0;x<innerW;x+=step){
          const nx=x/innerW, nz=y/innerH;
          const wx=BOUNDS.minX + nx*(BOUNDS.maxX-BOUNDS.minX);
          const wz=BOUNDS.minZ + nz*(BOUNDS.maxZ-BOUNDS.minZ);
          const h=heightAt(wx,wz);
          const t=THREE.MathUtils.clamp((h+2)/8,0,1);
          const a=0.12 + t*0.18;
          mmCtx.fillStyle=`rgba(205,255,140,${a})`;
          mmCtx.fillRect(pad+x,pad+y,step,step);
        }
      }

      // clearing ring
      const c=worldToMap(CLEARING.x,CLEARING.z);
      const cx=pad+c.x*innerW, cy=pad+c.y*innerH;
      mmCtx.strokeStyle="rgba(255,255,255,0.18)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.arc(cx,cy,(CLEARING.r/(BOUNDS.maxX-BOUNDS.minX))*innerW,0,Math.PI*2);
      mmCtx.stroke();

      // border
      mmCtx.strokeStyle="rgba(255,255,255,0.16)";
      mmCtx.lineWidth=1;
      mmRoundRect(mmCtx,0.5,0.5,W-1,H-1,18); mmCtx.stroke();

      // totems
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const m=worldToMap(t.x,t.z);
        const x=pad+m.x*innerW, y=pad+m.y*innerH;
        const isFocus=(i===focused);
        mmCtx.globalAlpha=isFocus?1:0.85;
        mmCtx.beginPath();
        mmCtx.strokeStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.55)";
        mmCtx.lineWidth=isFocus?3:2;
        mmCtx.arc(x,y,8,0,Math.PI*2); mmCtx.stroke();
        mmCtx.beginPath();
        mmCtx.fillStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.65)";
        mmCtx.arc(x,y,2.6,0,Math.PI*2); mmCtx.fill();
      }

      // player + heading
      const mp=worldToMap(camera.position.x,camera.position.z);
      const px=pad+mp.x*innerW, py=pad+mp.y*innerH;

      mmCtx.globalAlpha=0.55;
      mmCtx.fillStyle="rgba(205,255,140,0.35)";
      mmCtx.beginPath(); mmCtx.arc(px,py,14,0,Math.PI*2); mmCtx.fill();

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(255,255,255,0.92)";
      mmCtx.beginPath(); mmCtx.arc(px,py,4.2,0,Math.PI*2); mmCtx.fill();

      const ang=camera.rotation.y - Math.PI/2;
      mmCtx.strokeStyle="rgba(255,255,255,0.82)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.moveTo(px,py);
      mmCtx.lineTo(px + Math.cos(ang)*18, py + Math.sin(ang)*18);
      mmCtx.stroke();

      mmPos.textContent=`x ${camera.position.x.toFixed(1)} • z ${camera.position.z.toFixed(1)}`;

      let best={i:-1,d:1e9};
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const d=Math.hypot(t.x-camera.position.x, t.z-camera.position.z);
        if(d<best.d) best={i,d};
      }
      mmNear.textContent = best.i>=0 ? `Nearest: ${PACKS[best.i].name} (${best.d.toFixed(1)}m)` : "Nearest: —";

      const deg=(((-camera.rotation.y)*180/Math.PI)%360+360)%360;
      const dirs=["N","NE","E","SE","S","SW","W","NW"];
      mmHead.textContent = `${dirs[Math.round(deg/45)%8]} ↑`;
    }

    // Audio toggle (simple)
    let audioOn=false;
    soundBtn.addEventListener("click", ()=>{
      audioOn=!audioOn;
      soundBtn.setAttribute("aria-pressed", String(audioOn));
      soundBtn.textContent = audioOn ? "Sound: On" : "Sound: Off";
    });

    // Movement loop
    resetToClearing();
    const vel2 = new THREE.Vector3();
    const wish2 = new THREE.Vector3();
    let frames=0, fpsLast=performance.now();

    function animate(t){
      requestAnimationFrame(animate);
      const dt=Math.min(0.033, clock.getDelta());

      if(keys.q) camera.rotation.y += 1.55 * dt;
      if(keys.e) camera.rotation.y -= 1.55 * dt;

      camera.getWorldDirection(forward);
      forward.y=0; forward.normalize();
      right.crossVectors(forward, up).normalize();

      // ✅ FIXED WASD: W forward, S back
      const inputF = (keys.w ? 1 : 0) + (keys.s ? -1 : 0);
      const inputR = (keys.d ? 1 : 0) + (keys.a ? -1 : 0);

      const jF = mobile ? (-joyState.dy) : 0;
      const jR = mobile ? ( joyState.dx) : 0;

      wish2.set(0,0,0);
      wish2.addScaledVector(forward, inputF + jF);
      wish2.addScaledVector(right,   inputR + jR);

      const moving = wish2.lengthSq() > 0.0001;
      if(moving) wish2.normalize();

      const maxSpeed = (keys.shift ? 6.6 : 4.8) * (mobile ? 0.90 : 1);
      const accel = moving ? (keys.shift ? 18 : 14) : 0;
      const friction = moving ? 8 : 14;

      const targetVx = wish2.x * maxSpeed;
      const targetVz = wish2.z * maxSpeed;

      vel2.x += (targetVx - vel2.x) * Math.min(1, accel*dt);
      vel2.z += (targetVz - vel2.z) * Math.min(1, accel*dt);

      vel2.x *= Math.max(0, 1 - friction*dt);
      vel2.z *= Math.max(0, 1 - friction*dt);

      camera.position.x += vel2.x*dt;
      camera.position.z += vel2.z*dt;

      clampBoundsXZ(camera.position);
      resolveTreeCollisions(camera.position);

      const speed=Math.hypot(vel2.x, vel2.z);
      bob += dt*(2.2 + Math.min(1,speed/4.2)*6.5);
      const bobY = Math.sin(bob) * 0.05 * Math.min(1,speed/4.2);
      camera.position.y = heightAt(camera.position.x,camera.position.z) + 2.15 + bobY;

      const distToClearing = Math.hypot(camera.position.x-CLEARING.x, camera.position.z-CLEARING.z);
      zoneChip.textContent = distToClearing < CLEARING.r ? "Zone: Clearing" : (distToClearing < 75 ? "Zone: Forest" : "Zone: Edge");
      if(distToClearing > 110){
        const pull=0.020;
        camera.position.x += (CLEARING.x - camera.position.x)*pull;
        camera.position.z += (CLEARING.z - camera.position.z)*pull;
        vel2.multiplyScalar(0.92);
      }

      sky.position.copy(camera.position);
      sky.rotation.y += 0.00018;

      updateFocus();
      if(focused>=0){
        dockTitle.textContent=PACKS[focused].name;
        const tt=totems[focused];
        const d=Math.hypot(camera.position.x-tt.x, camera.position.z-tt.z);
        dockSub.textContent = d<4.8 ? "Press F to enter" : `Walk closer (${d.toFixed(1)}m)`;
      }else{
        dockTitle.textContent="Forest Clearing";
        dockSub.textContent="Find a totem.";
      }

      updateTotems(t);
      composer.render();
      drawMinimap();

      frames++;
      const now=performance.now();
      if(now-fpsLast>500){
        fpsChip.textContent = `FPS: ${Math.round(frames*1000/(now-fpsLast))}`;
        frames=0; fpsLast=now;
      }
    }

    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      composer.setSize(innerWidth, innerHeight);
    }, {passive:true});

    animate(performance.now());
  </script>
</body>
</html>
