<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Snack Packz — 3D Forest</title>
  <meta name="theme-color" content="#050705"/>

  <!-- ✅ FIX for GitHub Pages: allow "import ... from 'three'" -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <style>
    :root{
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --dim:rgba(255,255,255,.52);
      --accent:rgba(205,255,140,.92);
      --ease:cubic-bezier(.16,1,.3,1);
      --shadow: 0 30px 110px rgba(0,0,0,.70);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:#030403;
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    #stage{ position:fixed; inset:0; z-index:0; background:#020302; }

    .film{
      pointer-events:none;
      position:fixed; inset:0; z-index:40;
      background:
        radial-gradient(1000px 700px at 50% 45%, rgba(0,0,0,0) 0%, rgba(0,0,0,.18) 55%, rgba(0,0,0,.55) 100%),
        linear-gradient(180deg, rgba(0,0,0,.40) 0%, rgba(0,0,0,0) 22%, rgba(0,0,0,0) 78%, rgba(0,0,0,.45) 100%);
      mix-blend-mode: multiply;
      opacity:.95;
    }

    #topbar{
      position:fixed; left:18px; right:18px; top:16px;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      z-index:50;
      user-select:none;
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .seed{
      width:10px; height:10px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
    }
    .brand b{ font-weight:950; letter-spacing:.2px; }
    .brand small{ display:block; color:var(--dim); font-weight:700; margin-top:2px; }

    .controls{ display:flex; gap:10px; align-items:center; }
    .pill{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--fg);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:900;
      cursor:pointer;
      text-decoration:none;
      user-select:none;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
      white-space:nowrap;
    }
    .pill:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.20); }
    .pill.cta{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.30); }

    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      top: 94px;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      display:flex; gap:10px; align-items:center;
      user-select:none;
      z-index:50;
    }
    #hint .k{ font-weight:950; }
    #hint .s{ color:var(--muted); font-weight:800; }

    #dock{
      position:fixed; left:18px; right:18px; bottom:16px;
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      user-select:none;
      z-index:50;
    }
    .chips{ display:flex; gap:10px; align-items:center; }
    .chip{
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.76);
      font-weight:900;
      font-size:12px;
      white-space:nowrap;
    }

    #crosshair{
      position:fixed; left:50%; top:50%;
      width:10px; height:10px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: rgba(255,255,255,.78);
      box-shadow: 0 0 0 10px rgba(255,255,255,.05);
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:60;
    }

    #minimapHUD{
      position: fixed;
      right: 18px;
      bottom: 86px;
      width: 240px;
      border-radius: 22px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      padding: 10px;
      z-index: 60;
      user-select: none;
    }
    #minimapHUD .mmTop{
      display:flex; justify-content:space-between; align-items:baseline;
      gap:10px; padding: 4px 6px 8px;
    }
    #minimapHUD .mmTop b{ letter-spacing:.9px; font-weight:950; }
    #minimapHUD .mmHint{ color: rgba(255,255,255,.62); font-weight:850; font-size: 11px; }
    #minimapHUD canvas{ width: 220px; height: 220px; display:block; border-radius: 18px; }
    #minimapHUD .mmBottom{ display:flex; gap:8px; flex-wrap:wrap; padding: 8px 6px 2px; }
    #minimapHUD .mmChip{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding: 7px 10px;
      font-weight:900;
      font-size: 12px;
      color: rgba(255,255,255,.78);
    }

    #menu{
      position:fixed; inset:0; z-index:80;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding:18px;
    }
    #menuCard{
      width:min(520px, 94vw);
      border-radius:26px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      padding:16px;
    }
    #menuCard h2{ margin:6px 6px 10px; font-size:18px; letter-spacing:.2px; }
    #menuCard p{ margin:0 6px 14px; color: rgba(255,255,255,.70); font-weight:750; line-height:1.3; }
    .menuRow{ display:flex; gap:10px; flex-wrap:wrap; padding:6px; }
    .menuBtn{
      flex:1; min-width: 140px;
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding:12px 12px;
      background: rgba(255,255,255,.08);
      color: var(--fg);
      font-weight:950;
      cursor:pointer;
    }
    .menuBtn.primary{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.25); }

    /* Crash overlay */
    #err{
      position:fixed; left:18px; top:110px;
      width:min(820px, calc(100vw - 36px));
      background: rgba(255,0,0,.10);
      border:1px solid rgba(255,90,90,.35);
      border-radius: 18px;
      padding:12px 14px;
      z-index:999;
      display:none;
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
    }
    #err b{ display:block; font-weight:950; margin-bottom:6px; }
    #err pre{
      margin:0; white-space:pre-wrap; word-break:break-word;
      color: rgba(255,230,230,.95);
      font-weight:850; font-size:12px; line-height:1.25;
      max-height: 260px; overflow:auto;
    }

    @media (pointer:coarse), (max-width: 820px){
      #minimapHUD{ display:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>
  <div class="film"></div>

  <header id="topbar">
    <div class="brand">
      <span class="seed"></span>
      <div>
        <b>Snack Packz</b>
        <small>Click to lock • WASD move • Q/E turn • F enter • Esc menu</small>
      </div>
    </div>
    <div class="controls">
      <button id="exitBtn" class="pill" type="button">Exit</button>
      <button id="qualityBtn" class="pill" type="button" aria-pressed="true">Quality: Ultra</button>
      <a class="pill cta" href="shop.html">Order</a>
    </div>
  </header>

  <div id="hint">
    <div class="k">Click to lock</div>
    <div class="s">Aim at a totem → screen plays video. Walk up → F enters.</div>
  </div>

  <div id="dock">
    <div>
      <b id="dockTitle">Forest Clearing</b><br/>
      <small id="dockSub" style="color:rgba(255,255,255,.72);font-weight:750;">Find a totem.</small>
    </div>
    <div class="chips">
      <span class="chip" id="fpsChip">FPS: --</span>
      <span class="chip" id="stateChip">Click to lock</span>
    </div>
  </div>

  <div id="crosshair"></div>

  <div id="minimapHUD">
    <div class="mmTop">
      <b>MAP</b>
      <span class="mmHint">Clearing boundaries.</span>
    </div>
    <canvas id="mm" width="220" height="220"></canvas>
    <div class="mmBottom">
      <span class="mmChip" id="mmPos">x 0.0 • z 0.0</span>
      <span class="mmChip" id="mmNear">Nearest: —</span>
    </div>
  </div>

  <div id="menu">
    <div id="menuCard">
      <h2>Pause Menu</h2>
      <p>Resume, reset, or leave the forest.</p>
      <div class="menuRow">
        <button id="resumeBtn" class="menuBtn primary" type="button">Resume</button>
        <button id="resetBtn" class="menuBtn" type="button">Reset position</button>
        <button id="leaveBtn" class="menuBtn" type="button">Leave game</button>
      </div>
    </div>
  </div>

  <div id="err">
    <b>Crash reason</b>
    <pre id="errText"></pre>
  </div>

  <script>
    const errBox = document.getElementById("err");
    const errText = document.getElementById("errText");
    function showErr(msg){
      errBox.style.display="block";
      errText.textContent = String(msg || "Unknown error");
    }
    window.addEventListener("error",(e)=>{
      showErr(`${e.message}\n${e.filename || ""}:${e.lineno || ""}:${e.colno || ""}`);
    });
    window.addEventListener("unhandledrejection",(e)=>{
      showErr(`Unhandled rejection:\n${e.reason?.stack || e.reason?.message || e.reason || e}`);
    });
  </script>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { FilmPass } from "three/addons/postprocessing/FilmPass.js";

    // ===== Packs =====
    const PACKS = [
      { key:"fresh",  name:"FRESH",   tag:"Clean energy. Zero noise.",        page:"fresh.html",   poster:"assets/fresh.jpg",   video:"assets/fresh.mp4" },
      { key:"gaming", name:"GAMING",  tag:"Locked focus. Long sessions.",      page:"gaming.html",  poster:"assets/gaming.jpg",  video:"assets/gaming.mp4" },
      { key:"gym",    name:"GYM",     tag:"Explosive drive. Controlled burn.", page:"gym.html",     poster:"assets/gym.jpg",     video:"assets/gym.mp4" },
      { key:"work",   name:"WORK",    tag:"Calm clarity. Get it done.",        page:"work.html",    poster:"assets/work.jpg",    video:"assets/work.mp4" },
      { key:"lockin", name:"LOCK-IN", tag:"Tunnel vision. No distractions.",   page:"lock-in.html", poster:"assets/lockin.jpg",  video:"assets/lockin.mp4" }
    ];

    // ===== UI =====
    const canvas = document.getElementById("stage");
    const exitBtn = document.getElementById("exitBtn");
    const qualityBtn = document.getElementById("qualityBtn");
    const dockTitle = document.getElementById("dockTitle");
    const dockSub = document.getElementById("dockSub");
    const fpsChip = document.getElementById("fpsChip");
    const stateChip = document.getElementById("stateChip");

    const menu = document.getElementById("menu");
    const resumeBtn = document.getElementById("resumeBtn");
    const resetBtn = document.getElementById("resetBtn");
    const leaveBtn = document.getElementById("leaveBtn");

    const mm = document.getElementById("mm");
    const mmCtx = mm.getContext("2d");
    const mmPos = document.getElementById("mmPos");
    const mmNear = document.getElementById("mmNear");

    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const reduce = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;
    const mobile = coarse || innerWidth < 820;

    // ===== World bounds =====
    const BOUNDS = { minX:-55, maxX:55, minZ:-92, maxZ:26 };

    // ===== Quality =====
    const QUALITY = {
      ultra: !mobile && !reduce,
      set(v){
        this.ultra = v;
        qualityBtn.setAttribute("aria-pressed", String(v));
        qualityBtn.textContent = `Quality: ${v ? "Ultra" : "Lite"}`;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, v ? 2 : 1.25));
        scene.fog.near = v ? 28 : 18;
        scene.fog.far  = v ? 92 : 60;

        // post FX intensity
        bloomPass.strength = v ? 0.45 : 0.20;
        bloomPass.radius   = v ? 0.35 : 0.25;
        bloomPass.threshold= v ? 0.20 : 0.30;
       const fu = filmPass?.uniforms || filmPass?.material?.uniforms;
if (fu?.nIntensity) fu.nIntensity.value = v ? 0.22 : 0.12;
if (fu?.sIntensity) fu.sIntensity.value = v ? 0.35 : 0.20;


        // world density
        targetTreeCount = v ? 1500 : 820;
      }
    };

    // ===== Noise =====
    function hash2(x,z){
      let n = x * 374761393 + z * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }
    function smoothstep(t){ return t*t*(3-2*t); }
    function valueNoise(x,z){
      const xi = Math.floor(x), zi = Math.floor(z);
      const xf = x - xi, zf = z - zi;
      const a = hash2(xi,zi), b = hash2(xi+1,zi), c = hash2(xi,zi+1), d = hash2(xi+1,zi+1);
      const u = smoothstep(xf), v = smoothstep(zf);
      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return ab + (cd-ab)*v;
    }
    function fbm(x,z){
      let f=0, amp=1, freq=0.04;
      for(let i=0;i<5;i++){
        f += (valueNoise(x*freq, z*freq)-0.5)*2 * amp;
        amp *= 0.55;
        freq *= 2.0;
      }
      return f;
    }
    function heightAt(x,z){
      const base = fbm(x,z);
      const r = Math.sqrt(x*x + (z+18)*(z+18));
      const clearing = Math.max(0, 1 - (r/48));
      const flat = base * (1 - clearing*0.90);
      const micro = fbm(x*1.9, z*1.9) * 0.14;
      return flat*4.4 + micro;
    }

    // ===== Three.js =====
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x020302, 1);
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, QUALITY.ultra ? 2 : 1.25));

    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x050705, QUALITY.ultra ? 28 : 18, QUALITY.ultra ? 92 : 60);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.08, 420);
    camera.position.set(0, 2.2, 0);

    const controls = new PointerLockControls(camera, document.body);
    const clock = new THREE.Clock();

    // Lights
    scene.add(new THREE.HemisphereLight(0xbfe7c0, 0x0b0d0b, 0.78));
    const sun = new THREE.DirectionalLight(0xffffff, 0.72);
    sun.position.set(-12, 18, 12);
    scene.add(sun);

    // ===== Post-processing (Steam vibe) =====
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(innerWidth, innerHeight),
      QUALITY.ultra ? 0.45 : 0.20,
      QUALITY.ultra ? 0.35 : 0.25,
      QUALITY.ultra ? 0.20 : 0.30
    );
    composer.addPass(bloomPass);

    const filmPass = new FilmPass(
      QUALITY.ultra ? 0.35 : 0.20,  // noise
      QUALITY.ultra ? 0.22 : 0.12,  // scanlines
      648,                          // scanline count
      false
    );
    composer.addPass(filmPass);

    // ===== Cinema sky video =====
    const skyVideo = document.createElement("video");
    skyVideo.src = "assets/forest.mp4";
    skyVideo.loop = true;
    skyVideo.muted = true;
    skyVideo.playsInline = true;
    skyVideo.preload = "auto";

    const skyTex = new THREE.VideoTexture(skyVideo);
    skyTex.colorSpace = THREE.SRGBColorSpace;
    skyTex.minFilter = THREE.LinearFilter;
    skyTex.magFilter = THREE.LinearFilter;

    const sky = new THREE.Mesh(
      new THREE.SphereGeometry(220, 48, 32),
      new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide })
    );
    scene.add(sky);

    const skyGrade = new THREE.Mesh(
      new THREE.SphereGeometry(218, 32, 20),
      new THREE.MeshBasicMaterial({ color: 0x050705, transparent:true, opacity:0.38, side: THREE.BackSide })
    );
    scene.add(skyGrade);

    // ===== Terrain =====
    const size = 180;
    const seg = QUALITY.ultra ? 240 : 150;
    const terrainGeo = new THREE.PlaneGeometry(size, size, seg, seg);
    terrainGeo.rotateX(-Math.PI/2);

    const pos = terrainGeo.attributes.position;
    const colors = [];
    for(let i=0;i<pos.count;i++){
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const h = heightAt(x,z);
      pos.setY(i, h);

      const moss  = THREE.MathUtils.clamp((h+2)/6, 0, 1);
      const shade = THREE.MathUtils.clamp(0.55 + moss*0.45, 0, 1);

      const g = 0.18 + shade*0.56;
      const r = 0.10 + shade*0.22;
      const b = 0.10 + shade*0.18;
      colors.push(r,g,b);
    }
    terrainGeo.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));
    terrainGeo.computeVertexNormals();

    const terrain = new THREE.Mesh(
      terrainGeo,
      new THREE.MeshStandardMaterial({ vertexColors:true, roughness:1.0, metalness:0.0 })
    );
    scene.add(terrain);

    // ===== Trees (instanced) =====
    let targetTreeCount = QUALITY.ultra ? 1500 : 820;
    const treeCount = 1500; // max buffer, we can "fade" by not placing all on Lite

    const trunkGeo = new THREE.CylinderGeometry(0.10, 0.16, 2.2, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x2a1b12, roughness: 1.0 });
    const leafGeo  = new THREE.ConeGeometry(0.9, 2.6, 7);
    const leafMat  = new THREE.MeshStandardMaterial({ color: 0x0b2a12, roughness: 1.0 });

    const trunks = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
    const leaves = new THREE.InstancedMesh(leafGeo,  leafMat,  treeCount);
    scene.add(trunks, leaves);

    const dummy = new THREE.Object3D();
    const treeMeta = [];
    const treeColliders = [];

    function inClearing(x,z){
      const r = Math.sqrt(x*x + (z+18)*(z+18));
      return r < 30;
    }

    function rebuildTrees(){
      treeMeta.length = 0;
      treeColliders.length = 0;

      let placed = 0;
      let tries = 0;

      while(placed < targetTreeCount && tries < 500000){
        tries++;
        const x = THREE.MathUtils.randFloatSpread(135);
        const z = THREE.MathUtils.randFloatSpread(135);
        if(inClearing(x,z)) continue;

        const y = heightAt(x,z);
        const s = THREE.MathUtils.randFloat(0.85, 1.70);
        const rot = THREE.MathUtils.randFloat(0, Math.PI*2);

        dummy.position.set(x, y+1.1*s, z);
        dummy.rotation.set(0, rot, 0);
        dummy.scale.set(s,s,s);
        dummy.updateMatrix();
        trunks.setMatrixAt(placed, dummy.matrix);

        dummy.position.set(x, y+2.55*s, z);
        dummy.rotation.set(0, rot, 0);
        dummy.scale.set(s,s,s);
        dummy.updateMatrix();
        leaves.setMatrixAt(placed, dummy.matrix);

        treeMeta[placed] = { x, z, s, rot, phase: (x*0.11 + z*0.07) };

        if(Math.abs(x) < 70 && z > -120 && z < 60){
          treeColliders.push({x, z, r: 0.65*s});
        }

        placed++;
      }

      // hide unused instances
      const hide = new THREE.Matrix4().makeScale(0,0,0);
      for(let i=placed;i<treeCount;i++){
        trunks.setMatrixAt(i, hide);
        leaves.setMatrixAt(i, hide);
      }

      trunks.instanceMatrix.needsUpdate = true;
      leaves.instanceMatrix.needsUpdate = true;
    }
    rebuildTrees();

    // ===== Totems =====
    const loader = new THREE.TextureLoader();
    const totems = [];

    const packVideos = PACKS.map(p=>{
      const v = document.createElement("video");
      v.src = p.video;
      v.loop = true;
      v.muted = true;
      v.playsInline = true;
      v.preload = "auto";
      return v;
    });

    function makeTotem(p, i, x, z){
      const group = new THREE.Group();
      const y = heightAt(x,z);
      group.position.set(x, y+1.75, z);

      const frame = new THREE.Mesh(
        new THREE.BoxGeometry(2.05, 2.9, 0.12),
        new THREE.MeshStandardMaterial({ color: 0x0c0f0c, roughness: 0.55 })
      );
      group.add(frame);

      const posterTex = loader.load(p.poster);
      posterTex.colorSpace = THREE.SRGBColorSpace;

      const videoTex = new THREE.VideoTexture(packVideos[i]);
      videoTex.colorSpace = THREE.SRGBColorSpace;
      videoTex.minFilter = THREE.LinearFilter;
      videoTex.magFilter = THREE.LinearFilter;

      const screenMat = new THREE.MeshStandardMaterial({
        map: posterTex,
        roughness: 0.85,
        emissive: new THREE.Color(0x0c1a0c),
        emissiveIntensity: 0.36
      });

      const screen = new THREE.Mesh(new THREE.PlaneGeometry(1.78, 2.50), screenMat);
      screen.position.set(0,0,0.065);
      group.add(screen);

      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.32, 0.06, 10, 22),
        new THREE.MeshBasicMaterial({ color: 0xcfff8c })
      );
      ring.position.set(-0.70, 1.10, 0.09);
      group.add(ring);

      scene.add(group);
      totems.push({ p, i, x, z, group, screen, screenMat, posterTex, videoTex, ring });
    }

    const totemPositions = [
      {x:-14, z:-26},
      {x: 14, z:-26},
      {x:-9,  z:-40},
      {x:  9, z:-40},
      {x:  0, z:-32}
    ];
    PACKS.forEach((p,i)=> makeTotem(p,i, totemPositions[i].x, totemPositions[i].z));

    // ===== Input =====
    const keys = {w:false,a:false,s:false,d:false,q:false,e:false,shift:false};
    addEventListener("keydown",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="q") keys.q=true;
      if(k==="e") keys.e=true;
      if(k==="shift") keys.shift=true;

      if(k==="f") tryEnterFocused();
      if(k==="escape") openMenu();
      if(k==="r") resetPosition();
    });
    addEventListener("keyup",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="q") keys.q=false;
      if(k==="e") keys.e=false;
      if(k==="shift") keys.shift=false;
    });

    // Start media after first gesture (browser rule)
    let startedMedia=false;
    function startMedia(){
      if(startedMedia) return;
      startedMedia=true;
      skyVideo.play().catch(()=>{});
      for(const v of packVideos) v.play().catch(()=>{});
    }

    addEventListener("click",(e)=>{
      const t=e.target;
      if(t.closest && (t.closest("#topbar") || t.closest("#dock") || t.closest("#minimapHUD") || t.closest("#menu"))) return;
      startMedia();
      if(!mobile) controls.lock();
    });

    controls.addEventListener("lock", ()=> stateChip.textContent = "WASD • Q/E • F");
    controls.addEventListener("unlock", ()=> stateChip.textContent = "Click to lock");

    // ===== Menu =====
    function openMenu(){
      menu.style.display="flex";
      try{ controls.unlock(); }catch{}
    }
    function closeMenu(){
      menu.style.display="none";
      if(!mobile) controls.lock();
    }
    exitBtn.addEventListener("click", openMenu);
    resumeBtn.addEventListener("click", closeMenu);
    resetBtn.addEventListener("click", ()=>{ resetPosition(); closeMenu(); });
    leaveBtn.addEventListener("click", ()=>{ location.href="shop.html"; });

    // Quality toggle
    qualityBtn.addEventListener("click", ()=> {
      QUALITY.set(!QUALITY.ultra);
      rebuildTrees();
    });
    QUALITY.set(QUALITY.ultra);

    // ===== Focus / raycast =====
    const raycaster = new THREE.Raycaster();
    let focused = -1;

    function updateFocus(){
      focused = -1;
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const objects = totems.map(t=>t.screen);
      const hits = raycaster.intersectObjects(objects, false);
      if(hits.length){
        const idx = objects.indexOf(hits[0].object);
        if(idx >= 0) focused = idx;
      }
    }

    function tryEnterFocused(){
      if(focused < 0) return;
      const t = totems[focused];
      const d = Math.hypot(camera.position.x - t.x, camera.position.z - t.z);
      if(d < 4.4) location.href = t.p.page;
      else dockSub.textContent = `Walk closer (${d.toFixed(1)}m)`;
    }

    // ===== Physics =====
    function clampBounds(pos){
      pos.x = THREE.MathUtils.clamp(pos.x, BOUNDS.minX, BOUNDS.maxX);
      pos.z = THREE.MathUtils.clamp(pos.z, BOUNDS.minZ, BOUNDS.maxZ);
    }
    function resolveTreeCollisions(pos){
      for(let i=0;i<treeColliders.length;i++){
        const c = treeColliders[i];
        const dx = pos.x - c.x;
        const dz = pos.z - c.z;
        const d = Math.hypot(dx,dz);
        if(d > 0.0001 && d < c.r){
          const push = (c.r - d);
          pos.x += (dx / d) * push;
          pos.z += (dz / d) * push;
        }
      }
    }

    // ===== Steam-feel movement (Upgrade Pack 1) =====
    const vel = new THREE.Vector3(0,0,0);
    const dir = new THREE.Vector3();
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();
    const up = new THREE.Vector3(0,1,0);

    let yawVel = 0;
    let bobPhase = 0;

    function groundY(x,z){ return heightAt(x,z); }

    function resetPosition(){
      camera.position.set(0, groundY(0,0) + 2.2, 0);
      vel.set(0,0,0);
      yawVel = 0;
      bobPhase = 0;
      dockTitle.textContent = "Forest Clearing";
      dockSub.textContent = "Find a totem.";
    }
    resetPosition();

    // ===== Minimap =====
    function mmWorldToMap(wx,wz){
      const nx = (wx - BOUNDS.minX) / (BOUNDS.maxX - BOUNDS.minX);
      const nz = (wz - BOUNDS.minZ) / (BOUNDS.maxZ - BOUNDS.minZ);
      return { x:nx, y:nz };
    }
    function mmRoundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawMinimap(){
      if(mobile) return;

      const W=mm.width, H=mm.height;
      mmCtx.clearRect(0,0,W,H);

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(0,0,0,0.35)";
      mmRoundRect(mmCtx,0,0,W,H,18); mmCtx.fill();

      mmCtx.globalAlpha=.70;
      mmCtx.strokeStyle="rgba(205,255,140,0.18)";
      mmCtx.lineWidth=2;
      mmCtx.strokeRect(18,18,W-36,H-36);

      const pad=18;

      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const m=mmWorldToMap(t.x, t.z);
        const x=pad + m.x*(W-2*pad);
        const y=pad + m.y*(H-2*pad);
        const isFocus = (i===focused);

        mmCtx.globalAlpha=isFocus?1:0.85;
        mmCtx.beginPath();
        mmCtx.strokeStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.55)";
        mmCtx.lineWidth=isFocus?3:2;
        mmCtx.arc(x,y,8,0,Math.PI*2); mmCtx.stroke();

        mmCtx.beginPath();
        mmCtx.fillStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.65)";
        mmCtx.arc(x,y,2.6,0,Math.PI*2); mmCtx.fill();
      }

      const mp=mmWorldToMap(camera.position.x, camera.position.z);
      const px=pad + mp.x*(W-2*pad);
      const py=pad + mp.y*(H-2*pad);

      mmCtx.globalAlpha=0.55;
      mmCtx.fillStyle="rgba(205,255,140,0.35)";
      mmCtx.beginPath(); mmCtx.arc(px,py,14,0,Math.PI*2); mmCtx.fill();

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(255,255,255,0.92)";
      mmCtx.beginPath(); mmCtx.arc(px,py,4.2,0,Math.PI*2); mmCtx.fill();

      const ang = camera.rotation.y - Math.PI/2;
      mmCtx.strokeStyle="rgba(255,255,255,0.80)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.moveTo(px,py);
      mmCtx.lineTo(px + Math.cos(ang)*18, py + Math.sin(ang)*18);
      mmCtx.stroke();

      mmPos.textContent = `x ${camera.position.x.toFixed(1)} • z ${camera.position.z.toFixed(1)}`;

      let best={i:-1,d:1e9};
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const d=Math.hypot(t.x-camera.position.x, t.z-camera.position.z);
        if(d<best.d) best={i,d};
      }
      mmNear.textContent = best.i>=0 ? `Nearest: ${PACKS[best.i].name} (${best.d.toFixed(1)}m)` : "Nearest: —";
    }

    function updateTotems(time){
      for(let i=0;i<totems.length;i++){
        const t = totems[i];

        t.group.lookAt(camera.position.x, t.group.position.y, camera.position.z);

        const pulse = 0.5 + 0.5*Math.sin(time*0.002 + i);
        t.ring.scale.setScalar(1 + pulse*0.10);

        if(i === focused){
          if(t.screenMat.map !== t.videoTex){
            t.screenMat.map = t.videoTex;
            t.screenMat.needsUpdate = true;
          }
          t.screenMat.emissiveIntensity = 0.60;
        } else {
          if(t.screenMat.map !== t.posterTex){
            t.screenMat.map = t.posterTex;
            t.screenMat.needsUpdate = true;
          }
          t.screenMat.emissiveIntensity = 0.35;
        }
      }
    }

    // sway (simple)
    const m4 = new THREE.Matrix4();
    const q = new THREE.Quaternion();
    const v3 = new THREE.Vector3();
    const s3 = new THREE.Vector3();
    function swayTrees(time, frame){
      const swayEvery = QUALITY.ultra ? 2 : 4;
      if(frame % swayEvery !== 0) return;
      const step = QUALITY.ultra ? 3 : 5;

      for(let i=0;i<targetTreeCount;i+=step){
        const meta = treeMeta[i];
        if(!meta) continue;

        const w  = Math.sin(time*0.0012 + meta.phase) * 0.03;
        const w2 = Math.cos(time*0.0010 + meta.phase*1.3) * 0.02;
        const rotY = meta.rot + w2;

        q.setFromEuler(new THREE.Euler(w*0.25, rotY, 0));
        v3.set(meta.x, heightAt(meta.x, meta.z)+1.1*meta.s, meta.z);
        s3.set(meta.s, meta.s, meta.s);
        m4.compose(v3, q, s3);
        trunks.setMatrixAt(i, m4);

        q.setFromEuler(new THREE.Euler(w*0.9, rotY, w*0.35));
        v3.set(meta.x, heightAt(meta.x, meta.z)+2.55*meta.s, meta.z);
        m4.compose(v3, q, s3);
        leaves.setMatrixAt(i, m4);
      }
      trunks.instanceMatrix.needsUpdate = true;
      leaves.instanceMatrix.needsUpdate = true;
    }

    // ===== Resize =====
    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      composer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    }, {passive:true});

    // ===== Main loop =====
    let frames=0, fpsLast=performance.now(), frame=0;

    function animate(time){
      requestAnimationFrame(animate);
      frame++;

      const dt = Math.min(0.033, clock.getDelta());

      // Turn smoothing: Q/E adds angular velocity, then friction
      const turnAccel = 3.2;
      const turnFriction = 10.0;
      if(keys.q) yawVel += turnAccel * dt;
      if(keys.e) yawVel -= turnAccel * dt;
      yawVel -= yawVel * Math.min(1, turnFriction * dt);
      camera.rotation.y += yawVel * dt;

      // Input direction
      dir.set(0,0,0);
      if(keys.w) dir.z -= 1;
      if(keys.s) dir.z += 1;
      if(keys.a) dir.x -= 1;
      if(keys.d) dir.x += 1;
      if(dir.lengthSq() > 0) dir.normalize();

      // Build movement vector relative to view
      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      right.crossVectors(forward, up).normalize().negate();

      const wish = new THREE.Vector3()
        .addScaledVector(forward, dir.z)
        .addScaledVector(right,   dir.x);

      // Steam-feel numbers
      const run = keys.shift;
      const maxSpeed = (run ? 5.4 : 4.1) * (mobile ? 0.90 : 1);
      const accel = (run ? 18.0 : 14.0);
      const friction = 10.5;

      // accelerate towards wish direction
      if(wish.lengthSq() > 0){
        wish.normalize();
        vel.x += wish.x * accel * dt;
        vel.z += wish.z * accel * dt;
      } else {
        // friction when no input
        const f = Math.min(1, friction * dt);
        vel.x *= (1 - f);
        vel.z *= (1 - f);
      }

      // clamp horizontal speed
      const speed = Math.hypot(vel.x, vel.z);
      if(speed > maxSpeed){
        const k = maxSpeed / speed;
        vel.x *= k; vel.z *= k;
      }

      // apply movement
      camera.position.x += vel.x * dt;
      camera.position.z += vel.z * dt;

      // collisions + bounds
      clampBounds(camera.position);
      resolveTreeCollisions(camera.position);
      clampBounds(camera.position);

      // ground snap + headbob
      const gy = groundY(camera.position.x, camera.position.z);
      const moving = speed > 0.25;

      if(moving) bobPhase += dt * (run ? 11.0 : 9.0);
      else bobPhase *= 0.96;

      const bob = moving ? (Math.sin(bobPhase) * 0.06 + Math.sin(bobPhase*0.5) * 0.03) : 0;
      camera.position.y = gy + 2.2 + bob;

      // sky follows
      sky.position.copy(camera.position);
      sky.rotation.y += 0.00018;

      // focus + UI
      updateFocus();

      if(focused >= 0){
        dockTitle.textContent = PACKS[focused].name;
        const t = totems[focused];
        const d = Math.hypot(camera.position.x - t.x, camera.position.z - t.z);
        dockSub.textContent = d < 4.4 ? "Press F to enter" : `Walk closer (${d.toFixed(1)}m)`;
      } else {
        dockTitle.textContent = "Forest Clearing";
        dockSub.textContent = "Find a totem.";
      }

      updateTotems(time);
      swayTrees(time, frame);

      // render with post fx (always)
      composer.render();

      drawMinimap();

      // FPS
      frames++;
      const now=performance.now();
      if(now - fpsLast > 500){
        fpsChip.textContent = `FPS: ${Math.round(frames*1000/(now-fpsLast))}`;
        frames=0; fpsLast=now;
      }
    }

    animate(performance.now());
  </script>
</body>
</html>
