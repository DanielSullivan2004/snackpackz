<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Snack Packz — Forest</title>
  <meta name="theme-color" content="#050705"/>

  <style>
    :root{
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --dim:rgba(255,255,255,.50);
      --accent:rgba(205,255,140,.92);
      --ease:cubic-bezier(.16,1,.3,1);
      --shadow: 0 30px 110px rgba(0,0,0,.70);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:#050705;
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    /* WORLD */
    #world{ position:fixed; inset:0; z-index:-5; background:#020302; }
    #bg{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      transform: scale(1.12);
      filter: contrast(1.12) saturate(1.12) brightness(.80);
      will-change: transform;
      z-index:1;
    }

    /* Walkable floor (procedural) ABOVE video */
    #floor{
      position:absolute; inset:0;
      z-index:2;
      pointer-events:none;
      opacity:1;
      mix-blend-mode: normal;
    }

    /* Fog wall / boundary vibe */
    #fogWall{
      position:absolute; inset:0;
      z-index:3;
      pointer-events:none;
      background:
        radial-gradient(900px 520px at 50% 65%, rgba(0,0,0,0), rgba(0,0,0,.45) 60%, rgba(0,0,0,.80) 100%),
        radial-gradient(900px 520px at 50% 85%, rgba(205,255,140,.05), rgba(0,0,0,0) 60%);
      opacity:.95;
    }

    #fx{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; z-index:4; }

    #grade{
      position:absolute; inset:-1px; pointer-events:none; z-index:5;
      background:
        radial-gradient(1200px 700px at 18% 10%, rgba(0,0,0,.08), rgba(0,0,0,.70) 58%, rgba(0,0,0,.90) 100%),
        radial-gradient(900px 600px at 78% 18%, rgba(205,255,140,.07), rgba(0,0,0,0) 60%),
        linear-gradient(to bottom, rgba(0,0,0,.35), rgba(0,0,0,.14) 40%, rgba(0,0,0,.55));
    }

    /* TOP UI */
    #topbar{
      position:fixed; left:18px; right:18px; top:16px;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      z-index:30;
    }
    .brand{ display:flex; gap:10px; align-items:center; user-select:none; }
    .seed{
      width:10px; height:10px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
    }
    .brand b{ font-weight:900; letter-spacing:.2px; }
    .brand small{ display:block; color:var(--dim); font-weight:650; margin-top:2px; }

    .controls{ display:flex; gap:10px; align-items:center; }
    .pill{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--fg);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:850;
      cursor:pointer;
      text-decoration:none;
      user-select:none;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
      white-space:nowrap;
    }
    .pill:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.20);
    }
    .pill.cta{
      background: rgba(255,255,255,.90);
      color:#070a08;
      border-color: rgba(255,255,255,.30);
    }

    /* HINT */
    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      top: 94px;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      display:flex; gap:10px; align-items:center;
      user-select:none;
      z-index:30;
    }
    #hint .k{ font-weight:950; }
    #hint .s{ color:var(--muted); font-weight:750; }

    /* DOCK */
    #dock{
      position:fixed; left:18px; right:18px; bottom:16px;
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      user-select:none;
      z-index:30;
    }
    .chips{ display:flex; gap:10px; }
    .chip{
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.76);
      font-weight:850;
      font-size:12px;
      white-space:nowrap;
    }

    /* CROSSHAIR */
    #crosshair{
      position:fixed; left:50%; top:50%;
      width:10px; height:10px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: rgba(255,255,255,.78);
      box-shadow: 0 0 0 10px rgba(255,255,255,.05);
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:40;
    }

    /* TOTEMS */
    #totems{
      position:fixed; inset:0; z-index:25;
      perspective: 900px;
      perspective-origin: 50% 55%;
    }
    .totem{
      position:absolute;
      width:260px; height:360px;
      border-radius:28px;
      overflow:hidden;
      cursor:pointer;
      user-select:none;
      background:
        radial-gradient(600px 420px at 30% 20%, rgba(205,255,140,.10), transparent 60%),
        radial-gradient(600px 420px at 70% 20%, rgba(255,220,150,.06), transparent 60%),
        linear-gradient(180deg, rgba(0,0,0,.62), rgba(0,0,0,.20));
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      box-shadow: 0 40px 120px rgba(0,0,0,.72);
      will-change: transform, opacity;
      transition: border-color .2s var(--ease), filter .2s var(--ease);
    }
    .totem:hover{ border-color: rgba(255,255,255,.18); filter:saturate(1.04); }

    .cap{
      position:absolute; left:16px; right:16px; top:14px;
      display:flex; justify-content:space-between; gap:10px;
      z-index:3;
    }
    .name{ font-weight:950; letter-spacing:.8px; text-transform:uppercase; font-size:13px; }
    .tag{ color:rgba(255,255,255,.72); font-weight:750; font-size:12px; margin-top:6px; line-height:1.2; max-width:20ch; }
    .orb{
      width:10px; height:10px; border-radius:999px; margin-top:2px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
    }

    .window{
      position:absolute; left:14px; right:14px; top:78px;
      height:210px;
      border-radius:18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.35);
    }
    .window img, .window video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
    }
    .window video{ opacity:0; transition: opacity .35s var(--ease); }
    .window img{ opacity:1; transition: opacity .35s var(--ease); }

    .foot{
      position:absolute; left:14px; right:14px; bottom:14px;
      display:flex; justify-content:space-between; align-items:center; gap:10px;
      z-index:3;
    }
    .hint2{ color:rgba(255,255,255,.74); font-weight:850; font-size:12px; }
    .enter{
      padding:10px 12px; border-radius:999px;
      background: rgba(255,255,255,.90);
      color:#070a08;
      border:1px solid rgba(255,255,255,.25);
      font-weight:950;
    }

    /* MINIMAP */
    #minimapHUD{
      position: fixed;
      right: 18px;
      bottom: 86px;
      width: 240px;
      border-radius: 22px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      padding: 10px;
      z-index: 45;
      user-select: none;
    }
    #minimapHUD .mmTop{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      padding: 4px 6px 8px;
    }
    #minimapHUD .mmTop b{ letter-spacing:.9px; font-weight:950; }
    #minimapHUD .mmHint{ color: rgba(255,255,255,.62); font-weight:800; font-size: 11px; }
    #minimapHUD canvas{
      width: 220px; height: 220px;
      display:block;
      border-radius: 18px;
    }
    #minimapHUD .mmBottom{
      display:flex; gap:8px; flex-wrap:wrap;
      padding: 8px 6px 2px;
    }
    #minimapHUD .mmChip{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding: 7px 10px;
      font-weight:900;
      font-size: 12px;
      color: rgba(255,255,255,.78);
    }

    /* MOBILE CONTROLS */
    #mobileUI{
      position:fixed; left:0; right:0; bottom:0;
      padding:18px;
      display:none;
      justify-content:space-between;
      align-items:flex-end;
      gap:14px;
      z-index:50;
      pointer-events:none;
    }
    #joy{
      width:140px; height:140px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      position:relative;
      pointer-events:auto;
      touch-action:none;
    }
    #joyKnob{
      width:56px; height:56px;
      border-radius:999px;
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,.86);
      box-shadow: 0 18px 70px rgba(255,255,255,.12);
    }
    #useBtn{
      pointer-events:auto;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.90);
      color:#070a08;
      font-weight:950;
      border-radius: 18px;
      padding:16px 18px;
      min-width: 110px;
    }
    @media (pointer:coarse), (max-width: 820px){
      #mobileUI{ display:flex; }
      #minimapHUD{ display:none; }
    }
  </style>
</head>

<body>
  <div id="world" aria-hidden="true">
    <video id="bg" autoplay muted playsinline loop preload="auto">
      <source src="assets/forest.mp4" type="video/mp4"/>
    </video>

    <canvas id="floor"></canvas>
    <div id="fogWall"></div>
    <canvas id="fx"></canvas>
    <div id="grade"></div>
  </div>

  <header id="topbar">
    <div class="brand">
      <span class="seed"></span>
      <div>
        <b>Snack Packz</b>
        <small>Click to lock • WASD move • Q/E turn • F enter</small>
      </div>
    </div>
    <div class="controls">
      <button id="soundBtn" class="pill" type="button" aria-pressed="false">Sound: Off</button>
      <button id="qualityBtn" class="pill" type="button" aria-pressed="true">Quality: Ultra</button>
      <a class="pill cta" href="shop.html">Order</a>
    </div>
  </header>

  <div id="hint">
    <div class="k">Click to lock</div>
    <div class="s">WASD move • Q/E turn • Mouse look • F enter • Stay in the clearing</div>
  </div>

  <div id="totems"></div>

  <footer id="dock">
    <div>
      <b id="dockTitle">Forest Portal</b><br/>
      <small id="dockSub" style="color:rgba(255,255,255,.72);font-weight:700;">Walk towards a totem.</small>
    </div>
    <div class="chips">
      <span class="chip" id="fpsChip">FPS: --</span>
      <span class="chip" id="stateChip">Click to lock</span>
    </div>
  </footer>

  <div id="crosshair" aria-hidden="true"></div>

  <div id="minimapHUD" aria-hidden="true">
    <div class="mmTop">
      <b>MAP</b>
      <span class="mmHint">Clearing only. Forest is infinite.</span>
    </div>
    <canvas id="mm" width="220" height="220"></canvas>
    <div class="mmBottom">
      <span class="mmChip" id="mmPos">x 0.0 • z 0.0</span>
      <span class="mmChip" id="mmNear">Nearest: —</span>
    </div>
  </div>

  <div id="mobileUI" aria-hidden="true">
    <div id="joy"><div id="joyKnob"></div></div>
    <button id="useBtn" type="button">USE</button>
  </div>

  <script>
    const PACKS = [
      { key:"fresh",  name:"FRESH",  tag:"Clean energy. Zero noise.",         page:"fresh.html",   poster:"assets/fresh.jpg",   video:"assets/fresh.mp4" },
      { key:"gaming", name:"GAMING", tag:"Locked focus. Long sessions.",       page:"gaming.html",  poster:"assets/gaming.jpg",  video:"assets/gaming.mp4" },
      { key:"gym",    name:"GYM",    tag:"Explosive drive. Controlled burn.",  page:"gym.html",     poster:"assets/gym.jpg",     video:"assets/gym.mp4" },
      { key:"work",   name:"WORK",   tag:"Calm clarity. Get it done.",         page:"work.html",    poster:"assets/work.jpg",    video:"assets/work.mp4" },
      { key:"lockin", name:"LOCK-IN",tag:"Tunnel vision. No distractions.",    page:"lock-in.html", poster:"assets/lockin.jpg",  video:"assets/lockin.mp4" }
    ];

    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const reduce = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;
    const mobile = coarse || innerWidth < 820;

    const bg = document.getElementById("bg");
    const fx = document.getElementById("fx");
    const fxCtx = fx.getContext("2d");
    const floorC = document.getElementById("floor");
    const floorCtx = floorC.getContext("2d");
    const totemsHost = document.getElementById("totems");

    const soundBtn = document.getElementById("soundBtn");
    const qualityBtn = document.getElementById("qualityBtn");
    const fpsChip = document.getElementById("fpsChip");
    const stateChip = document.getElementById("stateChip");
    const dockTitle = document.getElementById("dockTitle");
    const dockSub = document.getElementById("dockSub");

    const mm = document.getElementById("mm");
    const mmCtx = mm.getContext("2d");
    const mmPos = document.getElementById("mmPos");
    const mmNear = document.getElementById("mmNear");

    const joy = document.getElementById("joy");
    const joyKnob = document.getElementById("joyKnob");
    const useBtn = document.getElementById("useBtn");
    document.getElementById("mobileUI").style.display = mobile ? "flex" : "none";

    const quality = {
      ultra: !mobile && !reduce,
      fxEvery: (!mobile && !reduce) ? 1 : 3,
      motes: (!mobile && !reduce) ? 46 : 16
    };

    let DPR = Math.min(devicePixelRatio || 1, 2);
    function resize(){
      DPR = Math.min(devicePixelRatio || 1, 2);
      fx.width = Math.floor(innerWidth * DPR);
      fx.height = Math.floor(innerHeight * DPR);
      fxCtx.setTransform(DPR,0,0,DPR,0,0);

      floorC.width = Math.floor(innerWidth * DPR);
      floorC.height = Math.floor(innerHeight * DPR);
      floorCtx.setTransform(DPR,0,0,DPR,0,0);
    }
    addEventListener("resize", resize, {passive:true});
    resize();

    // Player / camera
    const cam = { x:0, z:0, yaw:0, pitch:-0.06, vyaw:0, vpitch:0, speed:1.05 };

    // The "clearing" (gameplay arena). Forest video stays infinite.
    const BOUNDS = { minX:-9, maxX:9, minZ:-24, maxZ:2 };

    const world = {
      spawnX: 0, spawnZ: 0,
      totems: [
        {x:-4.8,z:-10.8},{x:4.9,z:-10.2},{x:-2.9,z:-16.4},{x:2.7,z:-15.9},{x:0.1,z:-13.2}
      ]
    };

    function resetPosition(){
      cam.x = world.spawnX;
      cam.z = world.spawnZ;
      cam.yaw = 0;
      cam.pitch = -0.06;
      stateChip.textContent = locked ? "WASD • Q/E • F" : "Click to lock";
    }

    // Pointer lock
    let locked = false;
    function tryLock(){ if(!mobile) document.body.requestPointerLock?.(); }
    document.addEventListener("pointerlockchange", ()=>{
      locked = (document.pointerLockElement === document.body);
      stateChip.textContent = locked ? "WASD • Q/E • F" : "Click to lock";
    });
    addEventListener("mousemove", (e)=>{
      if(!locked) return;
      cam.vyaw += (e.movementX||0) * 0.00185;
      cam.vpitch += (e.movementY||0) * 0.00145;
    }, {passive:true});

    addEventListener("click", (e)=>{
      const t = e.target;
      if(t && t.closest && (t.closest("#topbar") || t.closest("#dock") || t.closest("#mobileUI"))) return;
      if(!locked && !mobile) tryLock();
    });

    // Keyboard
    const keys = {w:false,a:false,s:false,d:false,q:false,e:false,shift:false};
    addEventListener("keydown",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="q") keys.q=true;
      if(k==="e") keys.e=true;
      if(k==="shift") keys.shift=true;
      if(k==="f") tryUse();
      if(k==="r") resetPosition();
    });
    addEventListener("keyup",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="q") keys.q=false;
      if(k==="e") keys.e=false;
      if(k==="shift") keys.shift=false;
    });

    // Mobile joystick + swipe look
    const joyState = {active:false,id:null,cx:0,cy:0,dx:0,dy:0};
    if(joy){
      joy.addEventListener("pointerdown",(e)=>{
        joyState.active=true; joyState.id=e.pointerId;
        joy.setPointerCapture(e.pointerId);
        const r=joy.getBoundingClientRect();
        joyState.cx=r.left+r.width/2; joyState.cy=r.top+r.height/2;
      });
      joy.addEventListener("pointermove",(e)=>{
        if(!joyState.active || e.pointerId!==joyState.id) return;
        const max=46;
        let dx=e.clientX-joyState.cx, dy=e.clientY-joyState.cy;
        const len=Math.hypot(dx,dy)||1;
        if(len>max){ dx=dx/len*max; dy=dy/len*max; }
        joyState.dx=dx/max; joyState.dy=dy/max;
        joyKnob.style.transform=`translate(${dx}px,${dy}px) translate(-50%,-50%)`;
      });
      const end=()=>{
        joyState.active=false; joyState.dx=0; joyState.dy=0;
        joyKnob.style.transform="translate(-50%,-50%)";
      };
      joy.addEventListener("pointerup",end);
      joy.addEventListener("pointercancel",end);
    }

    let look = {on:false,x:0,y:0};
    addEventListener("pointerdown",(e)=>{
      if(!mobile) return;
      if(e.target===joy || e.target===joyKnob || e.target===useBtn) return;
      look.on=true; look.x=e.clientX; look.y=e.clientY;
    },{passive:true});
    addEventListener("pointermove",(e)=>{
      if(!mobile || !look.on) return;
      const dx=e.clientX-look.x, dy=e.clientY-look.y;
      look.x=e.clientX; look.y=e.clientY;
      cam.vyaw += dx*0.0023;
      cam.vpitch += dy*0.00175;
    },{passive:true});
    addEventListener("pointerup",()=>{ look.on=false; },{passive:true});
    useBtn.addEventListener("click", tryUse);

    // Build totems
    const totems = [];
    function makeTotem(p,i){
      const el=document.createElement("div");
      el.className="totem";
      el.innerHTML = `
        <div class="cap">
          <div>
            <div class="name">${p.name}</div>
            <div class="tag">${p.tag}</div>
          </div>
          <div class="orb"></div>
        </div>
        <div class="window">
          <img src="${p.poster}" alt="${p.name} preview">
          <video muted playsinline loop preload="metadata"></video>
        </div>
        <div class="foot">
          <div class="hint2">Walk up + F</div>
          <div class="enter">Enter</div>
        </div>
      `;
      const img=el.querySelector("img");
      const vid=el.querySelector("video");
      let hovered=false, timer=null;

      async function prime(){
        if(vid.dataset.ready==="1") return true;
        vid.src=p.video; vid.dataset.ready="1";
        try{ await vid.play(); vid.pause(); vid.currentTime=0; return true; }
        catch{ return false; }
      }
      function showPoster(){ vid.style.opacity="0"; img.style.opacity="1"; try{vid.pause();}catch{} }
      function showVideo(){ vid.style.opacity="1"; img.style.opacity="0"; try{vid.play().catch(()=>{});}catch{} }

      el.addEventListener("mouseenter",()=>{
        hovered=true; showPoster();
        timer=setTimeout(async ()=>{
          if(!hovered) return;
          const ok=await prime();
          if(ok && hovered) showVideo();
        },140);
      });
      el.addEventListener("mouseleave",()=>{
        hovered=false; if(timer) clearTimeout(timer);
        showPoster();
      });

      el.addEventListener("click",()=>{
        const dist = getDist(i);
        if(dist < 2.2) location.href=p.page;
        else if(!locked && !mobile) tryLock();
      });

      const wp=world.totems[i];
      totems.push({el,p,wx:wp.x,wz:wp.z,wob:Math.random()*10});
      totemsHost.appendChild(el);
    }
    PACKS.forEach(makeTotem);

    function getDist(i){
      const t=totems[i];
      return Math.hypot(t.wx-cam.x, t.wz-cam.z);
    }

    // Projection (2.5D)
    const F = 820;
    function project(wx,wz){
      const dx=wx-cam.x;
      const dz=wz-cam.z;
      const c=Math.cos(-cam.yaw), s=Math.sin(-cam.yaw);
      const rx=dx*c - dz*s;
      const rz=dx*s + dz*c;
      return {x:rx,z:rz};
    }

    let focused=-1;
    function updateFocus(){
      focused=-1;
      let best=Infinity;
      for(let i=0;i<totems.length;i++){
        const rel=project(totems[i].wx, totems[i].wz);
        const dist=Math.hypot(rel.x, rel.z);
        const centre=Math.abs(rel.x);
        const score=centre + dist*0.10;
        if(score<best){ best=score; focused=i; }
      }
    }

    function tryUse(){
      if(focused<0) return;
      const dist=getDist(focused);
      if(dist < 2.2) location.href=totems[focused].p.page;
      else stateChip.textContent = `Too far (${dist.toFixed(1)}m)`;
    }

    // Collision + soft boundary push (no hard clamp snapping)
    function softBounds(){
      const pad = 0.6;
      const k = 0.20;
      if(cam.x < BOUNDS.minX+pad) cam.x += (BOUNDS.minX+pad - cam.x)*k;
      if(cam.x > BOUNDS.maxX-pad) cam.x -= (cam.x - (BOUNDS.maxX-pad))*k;
      if(cam.z < BOUNDS.minZ+pad) cam.z += (BOUNDS.minZ+pad - cam.z)*k;
      if(cam.z > BOUNDS.maxZ-pad) cam.z -= (cam.z - (BOUNDS.maxZ-pad))*k;
    }
    function resolveTotemCollision(){
      const R = 1.35;
      for(const t of totems){
        const dx = cam.x - t.wx;
        const dz = cam.z - t.wz;
        const d = Math.hypot(dx,dz);
        if(d > 0.0001 && d < R){
          const push = (R - d);
          cam.x += (dx / d) * push;
          cam.z += (dz / d) * push;
        }
      }
    }

    // FX motes
    let seed=1337;
    const rnd=()=> (seed=(seed*16807)%2147483647)/2147483647;
    let motes=[];
    function seedMotes(){
      motes=[];
      for(let i=0;i<quality.motes;i++){
        motes.push({x:rnd()*innerWidth,y:rnd()*innerHeight,z:0.15+rnd()*0.85,r:1+rnd()*2.6,p:rnd()*1000});
      }
    }
    seedMotes();

    soundBtn.addEventListener("click",()=>{
      const on = soundBtn.getAttribute("aria-pressed")!=="true";
      soundBtn.setAttribute("aria-pressed", String(on));
      soundBtn.textContent = `Sound: ${on ? "On" : "Off"}`;
      bg.muted = !on;
      bg.play().catch(()=>{});
    });

    qualityBtn.addEventListener("click",()=>{
      quality.ultra = !quality.ultra;
      quality.fxEvery = quality.ultra ? 1 : 3;
      quality.motes = quality.ultra ? 46 : 16;
      qualityBtn.setAttribute("aria-pressed", String(quality.ultra));
      qualityBtn.textContent = `Quality: ${quality.ultra ? "Ultra" : "Lite"}`;
      seedMotes();
    });

    // Procedural floor: draws a “clearing” that scrolls with cam.x/cam.z
    function drawFloor(){
      const w = innerWidth, h = innerHeight;
      floorCtx.clearRect(0,0,w,h);

      // ground plane gradient
      const g = floorCtx.createLinearGradient(0,h*0.55,0,h);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(0.28, "rgba(0,0,0,0.18)");
      g.addColorStop(1, "rgba(0,0,0,0.88)");
      floorCtx.fillStyle = g;
      floorCtx.fillRect(0,0,w,h);

      // fake “terrain noise” scrolling
      const baseY = h*0.66;
      const amp = 56;
      const scrollX = cam.x*48;
      const scrollZ = cam.z*46;

      floorCtx.globalAlpha = 0.55;
      for(let i=0;i<140;i++){
        const x = ((i*29 + scrollX) % (w+220)) - 110;
        const y = baseY + Math.sin((i*0.7) + scrollZ*0.03)*amp + (i%7)*2;
        const r = 80 + (i%9)*14;
        const a = 0.02 + (i%6)*0.004;
        floorCtx.fillStyle = `rgba(205,255,140,${a})`;
        floorCtx.beginPath();
        floorCtx.ellipse(x,y, r, r*0.48, 0, 0, Math.PI*2);
        floorCtx.fill();
      }

      // path stripe (centred, helps you not get lost)
      floorCtx.globalAlpha = 0.70;
      const pathW = Math.min(720, w*0.86);
      const px = (w-pathW)/2;
      const py = h*0.72;
      const pg = floorCtx.createLinearGradient(px,0,px+pathW,0);
      pg.addColorStop(0,"rgba(0,0,0,0)");
      pg.addColorStop(0.5,"rgba(255,255,255,0.10)");
      pg.addColorStop(1,"rgba(0,0,0,0)");
      floorCtx.fillStyle = pg;
      floorCtx.fillRect(px, py, pathW, 120);
    }

    // Minimap draw
    function mmWorldToMap(wx,wz){
      const nx = (wx - BOUNDS.minX) / (BOUNDS.maxX - BOUNDS.minX);
      const nz = (wz - BOUNDS.minZ) / (BOUNDS.maxZ - BOUNDS.minZ);
      return { x:nx, y:nz };
    }
    function mmRoundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawMinimap(){
      if(mobile) return;
      const W=mm.width, H=mm.height;
      mmCtx.clearRect(0,0,W,H);

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(0,0,0,0.35)";
      mmRoundRect(mmCtx,0,0,W,H,18); mmCtx.fill();

      mmCtx.globalAlpha=.45;
      mmCtx.strokeStyle="rgba(255,255,255,0.10)";
      mmCtx.lineWidth=1;
      for(let i=1;i<5;i++){
        const x=(W*i/5)|0, y=(H*i/5)|0;
        mmCtx.beginPath(); mmCtx.moveTo(x,10); mmCtx.lineTo(x,H-10); mmCtx.stroke();
        mmCtx.beginPath(); mmCtx.moveTo(10,y); mmCtx.lineTo(W-10,y); mmCtx.stroke();
      }

      mmCtx.globalAlpha=1;
      mmCtx.strokeStyle="rgba(255,255,255,0.18)";
      mmCtx.lineWidth=1;
      mmRoundRect(mmCtx,0.5,0.5,W-1,H-1,18); mmCtx.stroke();

      const pad=18;
      for(let i=0;i<world.totems.length;i++){
        const t=world.totems[i];
        const m=mmWorldToMap(t.x,t.z);
        const x=pad + m.x*(W-2*pad);
        const y=pad + m.y*(H-2*pad);
        const isFocus = (i===focused);

        mmCtx.globalAlpha=isFocus?1:0.85;
        mmCtx.beginPath();
        mmCtx.strokeStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.55)";
        mmCtx.lineWidth=isFocus?3:2;
        mmCtx.arc(x,y,8,0,Math.PI*2); mmCtx.stroke();

        mmCtx.beginPath();
        mmCtx.fillStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.65)";
        mmCtx.arc(x,y,2.6,0,Math.PI*2); mmCtx.fill();
      }

      const mp=mmWorldToMap(cam.x,cam.z);
      const px=pad + mp.x*(W-2*pad);
      const py=pad + mp.y*(H-2*pad);

      mmCtx.globalAlpha=0.55;
      mmCtx.fillStyle="rgba(205,255,140,0.35)";
      mmCtx.beginPath(); mmCtx.arc(px,py,14,0,Math.PI*2); mmCtx.fill();

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(255,255,255,0.92)";
      mmCtx.beginPath(); mmCtx.arc(px,py,4.2,0,Math.PI*2); mmCtx.fill();

      const ang = cam.yaw - Math.PI/2;
      mmCtx.strokeStyle="rgba(255,255,255,0.80)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.moveTo(px,py);
      mmCtx.lineTo(px + Math.cos(ang)*18, py + Math.sin(ang)*18);
      mmCtx.stroke();

      mmPos.textContent = `x ${cam.x.toFixed(1)} • z ${cam.z.toFixed(1)}`;
      let best={i:-1,d:1e9};
      for(let i=0;i<world.totems.length;i++){
        const t=world.totems[i];
        const d=Math.hypot(t.x-cam.x, t.z-cam.z);
        if(d<best.d) best={i,d};
      }
      mmNear.textContent = best.i>=0 ? `Nearest: ${PACKS[best.i].name} (${best.d.toFixed(1)}m)` : "Nearest: —";
    }

    // Loop
    let last=performance.now(), frames=0, fpsLast=performance.now(), fxFrame=0;

    function tick(t){
      // hard cap dt to stop jank teleports
      const dt = Math.min(22, t-last);
      last = t;

      // smooth look
      cam.yaw += cam.vyaw;
      cam.pitch += cam.vpitch;
      cam.vyaw *= 0.78;
      cam.vpitch *= 0.78;
      cam.pitch = Math.max(-0.35, Math.min(0.20, cam.pitch));

      // Q/E turning
      const turnRate = 0.95;
      if(keys.q) cam.yaw -= turnRate * (dt*0.001);
      if(keys.e) cam.yaw += turnRate * (dt*0.001);

      // movement
      let mx=0, mz=0;
      const sp = cam.speed * (keys.shift ? 1.25 : 1.0);

      if(keys.w) mz -= 1;
      if(keys.s) mz += 1;
      if(keys.a) mx -= 1;
      if(keys.d) mx += 1;

      if(mobile){ mx += joyState.dx; mz += joyState.dy; }

      const len = Math.hypot(mx,mz) || 1;
      mx/=len; mz/=len;

      const sin=Math.sin(cam.yaw), cos=Math.cos(cam.yaw);
      const step = 0.0062;
      cam.x += (mx*cos - mz*sin) * sp * dt * step;
      cam.z += (mx*sin + mz*cos) * sp * dt * step;

      resolveTotemCollision();
      softBounds();

      // background parallax (keeps infinite vibe)
      const bx = Math.sin(cam.yaw) * 18;
      const by = cam.pitch * 38;
      bg.style.transform = `translate(${bx}px,${by}px) scale(${quality.ultra?1.12:1.08})`;

      // Focus + draw totems (NEVER DISAPPEAR)
      updateFocus();
      const cx=innerWidth*0.5, cy=innerHeight*0.52;

      for(let i=0;i<totems.length;i++){
        const o=totems[i];
        const rel=project(o.wx,o.wz);

        // If behind camera, show as ghost marker at screen edge instead of disappearing.
        const behind = (rel.z > -0.25);

        // compute normal projection even if behind (we'll clamp)
        const safeZ = behind ? -0.55 : rel.z;
        const inv = 1/(-safeZ);

        let sx = cx + rel.x*inv*F;
        let sy = cy + cam.pitch*120;

        const wob = Math.sin(t*0.0012 + o.wob) * 6;

        // scale/alpha
        let scale = Math.max(0.35, Math.min(1.35, inv*2.15));
        let alpha = Math.max(0.18, Math.min(1.0, inv*1.15));

        // ghost behaviour
        if(behind){
          alpha = 0.22;
          scale = 0.42;
          // clamp to edges so you can “find” them again
          sx = Math.max(60, Math.min(innerWidth-320, sx));
          sy = Math.max(140, Math.min(innerHeight-460, sy));
        }

        // face player
        const face = Math.max(-18, Math.min(18, (-rel.x) * 6));

        o.el.style.opacity = String(alpha);
        o.el.style.pointerEvents = behind ? "none" : "auto";
        o.el.style.zIndex = String(Math.floor(scale*1000));

        o.el.style.transform =
          `translate(${(sx-130).toFixed(2)}px,${(sy-210+wob).toFixed(2)}px)
           rotateY(${face.toFixed(2)}deg)
           scale(${scale.toFixed(4)})`;

        if(i===focused && !behind){
          o.el.style.borderColor="rgba(255,255,255,.34)";
          dockTitle.textContent=o.p.name;
          const d=getDist(i);
          dockSub.textContent = d<2.2 ? "Press F / USE to enter" : `Walk closer (${d.toFixed(1)}m)`;
          stateChip.textContent = d<2.2 ? "Interact: F / USE" : "Move closer";
        }else{
          o.el.style.borderColor="rgba(255,255,255,.10)";
        }
      }

      // draw floor + minimap
      drawFloor();
      drawMinimap();

      // FX motes
      fxFrame++;
      if(!reduce && (fxFrame % quality.fxEvery === 0)){
        fxCtx.clearRect(0,0,innerWidth,innerHeight);
        fxCtx.globalCompositeOperation="screen";
        for(const m of motes){
          m.p += dt*0.0006;
          const x = (m.x + Math.sin(m.p)*14 + Math.sin(cam.yaw)*80*(1-m.z)) % innerWidth;
          const y = (m.y + Math.cos(m.p)*10 + cam.pitch*60*(1-m.z)) % innerHeight;
          fxCtx.globalAlpha = 0.05 + m.z*0.18;
          fxCtx.fillStyle="rgba(255,255,255,.90)";
          fxCtx.beginPath(); fxCtx.arc(x,y,m.r,0,Math.PI*2); fxCtx.fill();
        }
      }

      // FPS
      frames++;
      const now=performance.now();
      if(now-fpsLast>500){
        fpsChip.textContent=`FPS: ${Math.round(frames*1000/(now-fpsLast))}`;
        frames=0; fpsLast=now;
      }

      requestAnimationFrame(tick);
    }

    // Start
    bg.play().catch(()=>{});
    resetPosition();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
