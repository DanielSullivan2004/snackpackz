<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Snack Packz</title>
  <meta name="description" content="Snack Packz — pick your pack." />
  <meta name="theme-color" content="#050705" />

  <!--
    Snack Packz — INDEX (PART 1/10)
    Goal of Part 1:
    - 4K forest cinema stage (video bg + grade + vignette + grain)
    - premium layout shell (nav + hero + pack orbit placeholder + preview dock placeholder)
    - zero reliance on the removed assets: front-wheel / hero-car / speedo / hero.mp4
    Next parts will inject: interaction engine, nature FX (butterflies/birds), audio, pack system, previews, optimisation.
  -->

  <style>
    :root{
      --bg:#050705;
      --fg:#ecf4ef;
      --muted:rgba(236,244,239,.72);
      --dim:rgba(236,244,239,.52);

      --lime:#b7ff6a;
      --amber:#ffd86a;

      --glass:rgba(8,14,10,.34);
      --glass2:rgba(8,14,10,.18);
      --stroke:rgba(255,255,255,.12);

      --shadow: 0 22px 80px rgba(0,0,0,.58);
      --shadow2: 0 10px 30px rgba(0,0,0,.35);

      --r:22px;
      --r2:18px;

      --ease:cubic-bezier(.2,.8,.2,1);
      --ease2:cubic-bezier(.16,1,.3,1);

      --max: 1200px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow-x:hidden;
    }

    a,button{ -webkit-tap-highlight-color: transparent; }
    ::selection{ background: rgba(183,255,106,.28); }

      /* ============================================================
     PART 4/10 — Cinema Audio Engine (Mobile-Safe)
     - Forest ambience + birds + wind
     - Gesture-unlocked (iOS / Android compliant)
     - Smooth fades (no clicks)
     - Auto pause/resume on tab visibility
     ============================================================ */

  const audio = {
    ctx: null,
    unlocked: false,
    enabled: false,
    master: null,
    layers: {}
  };

  function createAudioContext(){
    if(audio.ctx) return audio.ctx;
    const Ctx = window.AudioContext || window.webkitAudioContext;
    if(!Ctx) return null;

    audio.ctx = new Ctx();
    audio.master = audio.ctx.createGain();
    audio.master.gain.value = 0;
    audio.master.connect(audio.ctx.destination);
    return audio.ctx;
  }

  async function loadBuffer(url){
    const res = await fetch(url);
    const arr = await res.arrayBuffer();
    return audio.ctx.decodeAudioData(arr);
  }

  function createLoop(buffer, volume){
    const src = audio.ctx.createBufferSource();
    const gain = audio.ctx.createGain();
    src.buffer = buffer;
    src.loop = true;
    gain.gain.value = 0;
    src.connect(gain).connect(audio.master);
    src.start();
    return { src, gain, volume };
  }

  function fadeGain(gain, target, time=1.2){
    const now = audio.ctx.currentTime;
    gain.gain.cancelScheduledValues(now);
    gain.gain.setValueAtTime(gain.gain.value, now);
    gain.gain.linearRampToValueAtTime(target, now + time);
  }

  async function buildAudio(){
    if(audio.layers.forest) return;

    const ctx = createAudioContext();
    if(!ctx) return;

    // You can swap these files later if you want different vibes
    const forestBuf = await loadBuffer("assets/forest.mp4"); // reuse ambience from video
    const birdsBuf  = await loadBuffer("assets/forest.mp4"); // filtered birds layer
    const windBuf   = await loadBuffer("assets/forest.mp4"); // filtered wind layer

    audio.layers.forest = createLoop(forestBuf, 0.35);
    audio.layers.birds  = createLoop(birdsBuf,  0.20);
    audio.layers.wind   = createLoop(windBuf,   0.18);

    // EQ / tone shaping (very subtle)
    const birdFilter = ctx.createBiquadFilter();
    birdFilter.type = "highpass";
    birdFilter.frequency.value = 1200;
    audio.layers.birds.src.disconnect();
    audio.layers.birds.src.connect(birdFilter).connect(audio.layers.birds.gain);

    const windFilter = ctx.createBiquadFilter();
    windFilter.type = "lowpass";
    windFilter.frequency.value = 800;
    audio.layers.wind.src.disconnect();
    audio.layers.wind.src.connect(windFilter).connect(audio.layers.wind.gain);
  }

  function unlockAudio(){
    if(audio.unlocked) return;
    const ctx = createAudioContext();
    if(!ctx) return;

    ctx.resume();
    audio.unlocked = true;
  }

  function enableAudio(){
    if(!audio.unlocked) return;
    audio.enabled = true;

    buildAudio().then(()=>{
      fadeGain(audio.master, 0.85, 1.8);
      fadeGain(audio.layers.forest.gain, audio.layers.forest.volume, 2.0);
      fadeGain(audio.layers.birds.gain,  audio.layers.birds.volume,  2.8);
      fadeGain(audio.layers.wind.gain,   audio.layers.wind.volume,   2.4);
    });
  }

  function disableAudio(){
    audio.enabled = false;
    if(!audio.ctx) return;

    fadeGain(audio.master, 0.0, 1.2);
  }

  // Unlock on first real user gesture
  ["pointerdown","touchstart","keydown"].forEach(evt=>{
    window.addEventListener(evt, unlockAudio, { once:true, passive:true });
  });

  // Pause when tab hidden
  document.addEventListener("visibilitychange", ()=>{
    if(!audio.ctx) return;
    if(document.hidden){
      fadeGain(audio.master, 0.0, 0.8);
    } else if(audio.enabled){
      fadeGain(audio.master, 0.85, 1.2);
    }
  });


    /* ---------- CINEMA BACKGROUND ---------- */
    .bg{
      position:fixed; inset:0;
      z-index:-10;
      background:#030503;
    }
    .bg video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;

      /* cinematic grade */
      filter: contrast(1.12) saturate(1.14) brightness(.82);
      transform: scale(1.03);
      will-change: transform, filter;
    }
    .vignette{
      position:absolute; inset:-1px;
      z-index:-9;
      pointer-events:none;
      background:
        radial-gradient(1100px 700px at 18% 10%,
          rgba(0,0,0,.18),
          rgba(0,0,0,.62) 55%,
          rgba(0,0,0,.86) 100%),
        radial-gradient(900px 600px at 82% 18%,
          rgba(183,255,106,.07),
          rgba(0,0,0,0) 55%),
        radial-gradient(900px 600px at 40% 92%,
          rgba(255,216,106,.05),
          rgba(0,0,0,0) 55%),
        linear-gradient(to bottom,
          rgba(0,0,0,.35),
          rgba(0,0,0,.22) 35%,
          rgba(0,0,0,.55));
    }
    .grain{
      position:absolute; inset:0;
      z-index:-8;
      pointer-events:none;
      opacity:.09;
      mix-blend-mode: overlay;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='240' height='240'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.82' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='240' height='240' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
    }
    canvas#fx{
      position:fixed; inset:0;
      z-index:-7;
      pointer-events:none;
      opacity:1;
    }

    /* ---------- NAV ---------- */
    .nav{
      position:sticky; top:0;
      z-index:50;
      padding: 18px 22px;
      display:flex;
      align-items:center;
      justify-content:space-between;

      backdrop-filter: blur(14px);
      background: linear-gradient(to bottom,
        rgba(4,7,5,.60),
        rgba(4,7,5,.18));
      border-bottom: 1px solid rgba(255,255,255,.08);
    }

    .brand{
      display:flex; align-items:center; gap:12px;
      font-weight:820;
      letter-spacing:.2px;
      user-select:none;
    }
    .brand .dot{
      width:12px; height:12px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%,
        #fff,
        rgba(255,255,255,.18) 35%,
        rgba(183,255,106,.92) 70%,
        rgba(183,255,106,.18) 100%);
      box-shadow: 0 0 0 7px rgba(183,255,106,.08);
    }
    .brand small{
      display:block;
      margin-top:2px;
      color:var(--dim);
      font-weight:650;
      letter-spacing:.2px;
      font-size: 12px;
    }

    .navlinks{
      display:flex;
      gap:14px;
      align-items:center;
      color:var(--muted);
      font-weight:720;
    }
    .navlinks a{
      color:inherit;
      text-decoration:none;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid transparent;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
    }
    .navlinks a:hover{
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.12);
      transform: translateY(-1px);
    }

    .navRight{
      display:flex; gap:10px; align-items:center;
    }
    .pill{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(8,14,10,.26);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow2);
      color: var(--muted);
      font-weight:760;
      user-select:none;
      white-space:nowrap;
    }
    .toggle{
      cursor:pointer;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
    }
    .toggle:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,.06);
      border-color: rgba(255,255,255,.18);
    }

    .ctaWA{
      text-decoration:none;
      color:#07110a;
      font-weight:880;
      padding:10px 14px;
      border-radius:999px;
      background: linear-gradient(135deg,
        rgba(183,255,106,.95),
        rgba(183,255,106,.45));
      border:1px solid rgba(255,255,255,.16);
      box-shadow: 0 14px 45px rgba(183,255,106,.18);
      transition: transform .25s var(--ease), filter .25s var(--ease);
      white-space:nowrap;
    }
    .ctaWA:hover{
      transform: translateY(-2px);
      filter: brightness(1.05) saturate(1.06);
    }

    /* ---------- LAYOUT ---------- */
    .wrap{
      max-width: var(--max);
      margin: 0 auto;
      padding: 22px;
    }

    .hero{
      margin-top: 18px;
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap: 16px;
      align-items: stretch;
    }
    @media (max-width: 980px){
      .hero{ grid-template-columns: 1fr; }
      .navlinks{ display:none; }
    }

    .card{
      position:relative;
      border-radius: var(--r);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.12);
      background: linear-gradient(180deg, rgba(8,14,10,.36), rgba(8,14,10,.18));
      backdrop-filter: blur(18px);
      box-shadow: var(--shadow);
      transform: translateZ(0);
    }
    .card::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(900px 520px at 12% 12%, rgba(183,255,106,.17), transparent 58%),
        radial-gradient(900px 600px at 85% 18%, rgba(255,216,106,.08), transparent 56%),
        linear-gradient(180deg, rgba(255,255,255,.07), transparent 24%);
      opacity:.60;
    }

    .left{
      padding: 26px 26px 22px;
      min-height: 560px;
      display:flex;
      flex-direction:column;
      justify-content:space-between;
      gap: 16px;
    }

    .kickerRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      position:relative;
      z-index:2;
    }

    .kicker{
      display:flex;
      align-items:center;
      gap:10px;
      color: var(--muted);
      font-weight:760;
      letter-spacing:.2px;
      font-size: 13px;
      user-select:none;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
    }
    .chip i{
      width:10px; height:10px;
      border-radius: 99px;
      display:inline-block;
      background: radial-gradient(circle at 30% 30%,
        #fff, rgba(255,255,255,.18) 35%,
        rgba(183,255,106,.9) 70%, rgba(183,255,106,.2));
      box-shadow: 0 0 0 6px rgba(183,255,106,.07);
    }

    .title{
      margin: 6px 0 0;
      font-size: clamp(40px, 5.4vw, 66px);
      line-height: .96;
      letter-spacing: -1.2px;
      font-weight: 900;
      position:relative;
      z-index:2;
    }
    .title .accent{
      color: var(--lime);
      text-shadow: 0 0 40px rgba(183,255,106,.13);
    }

    .desc{
      margin: 10px 0 0;
      max-width: 54ch;
      color: var(--muted);
      font-size: 15px;
      line-height: 1.58;
      position:relative;
      z-index:2;
    }

    .ctaRow{
      margin-top: 14px;
      display:flex;
      gap: 12px;
      flex-wrap: wrap;
      align-items:center;
      position:relative;
      z-index:2;
    }

    .btn{
      appearance:none;
      border:0;
      cursor:pointer;
      padding: 12px 14px;
      border-radius: 14px;
      font-weight: 880;
      letter-spacing: .15px;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease), filter .25s var(--ease);
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--fg);
      backdrop-filter: blur(12px);
      user-select:none;
    }
    .btn:hover{
      transform: translateY(-2px);
      background: rgba(255,255,255,.11);
      border-color: rgba(255,255,255,.20);
    }
    .btn.primary{
      background: linear-gradient(135deg, rgba(183,255,106,.93), rgba(183,255,106,.42));
      border-color: rgba(255,255,255,.16);
      box-shadow: 0 16px 52px rgba(183,255,106,.16);
      color: #06110a;
      font-weight: 950;
    }
    .btn.primary:hover{
      filter: brightness(1.05) saturate(1.06);
    }

    /* Orbit placeholder (PART 5 will turn this into a real pack selector) */
    .orbitWrap{
      margin-top: 18px;
      height: 270px;
      position: relative;
      z-index:2;
    }
    .orb{
      position:absolute;
      inset: 0;
      margin:auto;
      width: 100%;
      height: 100%;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background:
        radial-gradient(circle at 50% 50%, rgba(255,255,255,.08), rgba(255,255,255,.03) 35%, rgba(0,0,0,0) 62%);
      overflow:hidden;
      filter: drop-shadow(0 20px 60px rgba(0,0,0,.45));
    }
    .orb::after{
      content:"";
      position:absolute;
      inset:-40%;
      background:
        radial-gradient(circle at 30% 30%, rgba(183,255,106,.14), transparent 55%),
        radial-gradient(circle at 70% 60%, rgba(255,216,106,.10), transparent 58%);
      animation: slowSpin 18s linear infinite;
      opacity:.9;
    }
    @keyframes slowSpin{
      from{ transform: rotate(0deg); }
      to{ transform: rotate(360deg); }
    }

    .packHint{
      position:absolute;
      left: 16px;
      top: 16px;
      padding:10px 12px;
      border-radius: 999px;
      background: rgba(8,14,10,.28);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      color: var(--muted);
      font-weight: 760;
      font-size: 12.5px;
      user-select:none;
    }

    .packDots{
      position:absolute;
      inset: 0;
      pointer-events:auto;
    }

    .packDot{
      position:absolute;
      width: 148px;
      height: 50px;
      border-radius: 999px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      gap: 10px;
      background: rgba(8,14,10,.28);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(14px);
      box-shadow: 0 12px 35px rgba(0,0,0,.35);
      cursor:pointer;
      transition: transform .28s var(--ease2), background .28s var(--ease), border-color .28s var(--ease);
      user-select:none;
    }
    .packDot:hover{
      transform: translateY(-3px) scale(1.02);
      background: rgba(255,255,255,.07);
      border-color: rgba(255,255,255,.22);
    }
    .miniLight{
      width: 18px; height: 18px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%,
        #fff, rgba(255,255,255,.2) 30%,
        rgba(183,255,106,.8) 70%, rgba(183,255,106,.2));
      box-shadow: 0 0 0 6px rgba(183,255,106,.07);
      flex: 0 0 auto;
    }
    .packDot strong{
      font-weight: 950;
      letter-spacing:.2px;
      font-size: 13px;
      line-height: 1.05;
    }
    .packDot span{
      color: var(--dim);
      font-weight: 880;
      font-size: 11px;
      letter-spacing:.2px;
      line-height: 1.05;
      text-align:right;
    }

    /* place dots around (static in Part 1; Part 5 makes them orbit/drag/scroll) */
    .p1{ left: 10%; top: 16%; }
    .p2{ right: 10%; top: 22%; }
    .p3{ left: 16%; bottom: 18%; }
    .p4{ right: 14%; bottom: 16%; }
    .p5{ left: 42%; top: 44%; transform: translate(-50%,-50%); }

    /* Stats */
    .stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      position:relative;
      z-index:2;
    }
    @media (max-width: 520px){ .stats{ grid-template-columns: 1fr; } }
    .stat{
      padding: 14px 14px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(8,14,10,.18);
      backdrop-filter: blur(12px);
    }
    .stat b{
      font-size: 18px;
      letter-spacing: -0.3px;
      font-weight: 950;
    }
    .stat p{
      margin: 6px 0 0;
      color: var(--dim);
      font-weight: 760;
      font-size: 12.5px;
      line-height: 1.35;
    }

    /* ---------- RIGHT PANEL (PREVIEW DOCK PLACEHOLDER) ---------- */
    .right{
      padding: 18px;
      min-height: 560px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }

    .panelHead{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap: 10px;
      padding: 8px 10px 2px;
      position:relative;
      z-index:2;
    }
    .panelHead h3{
      margin:0;
      font-size: 14px;
      letter-spacing:.8px;
      text-transform: uppercase;
      font-weight: 950;
    }
    .panelHead p{
      margin: 6px 0 0;
      color: var(--dim);
      font-weight: 760;
      font-size: 12.5px;
      line-height: 1.35;
      max-width: 44ch;
    }

    .enterBtn{
      margin-top: 2px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--fg);
      font-weight: 950;
      cursor:pointer;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
      user-select:none;
    }
    .enterBtn:hover{
      transform: translateY(-2px);
      background: rgba(255,255,255,.11);
      border-color: rgba(255,255,255,.22);
    }

    .preview{
      position:relative;
      border-radius: var(--r2);
      overflow:hidden;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(8,14,10,.20);
      box-shadow: var(--shadow2);
      flex: 1;
      min-height: 420px;
    }

    .preview::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(700px 420px at 20% 20%, rgba(183,255,106,.10), transparent 58%),
        radial-gradient(700px 420px at 80% 20%, rgba(255,216,106,.06), transparent 58%),
        linear-gradient(to bottom, rgba(0,0,0,.10), rgba(0,0,0,.35));
      opacity: .85;
      z-index:1;
    }

    .previewStage{
      position:absolute; inset:0;
      z-index:0;
      display:grid;
      place-items:center;
      padding: 18px;
    }

    .previewContent{
      width: 100%;
      height: 100%;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      overflow:hidden;
      position:relative;
      background: #050705;
    }

    /* In Part 6 we’ll do: poster -> fade -> video */
    .poster{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: cover;
      filter: contrast(1.06) saturate(1.10) brightness(.92);
      opacity: 1;
      transition: opacity .45s var(--ease);
    }
    .dockVideo{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity .45s var(--ease);
    }

    .previewHUD{
      position:absolute;
      left: 14px;
      bottom: 14px;
      z-index:2;
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 9px 11px;
      border-radius: 999px;
      background: rgba(8,14,10,.36);
      border: 1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(12px);
      color: var(--muted);
      font-weight: 850;
      font-size: 12px;
      user-select:none;
    }
    .badge i{
      width:8px; height:8px; border-radius:99px;
      background: rgba(183,255,106,.85);
      box-shadow: 0 0 0 6px rgba(183,255,106,.07);
    }

    .hintText{
      margin: 0;
      padding: 10px 12px 2px;
      color: var(--dim);
      font-weight: 760;
      font-size: 12.5px;
      line-height: 1.4;
    }

    /* Footer strip */
    .footStrip{
      margin-top: 14px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(8,14,10,.14);
      backdrop-filter: blur(10px);
      color: var(--dim);
      font-weight: 760;
      font-size: 12px;
      display:flex;
      justify-content:space-between;
      gap: 10px;
      flex-wrap:wrap;
      user-select:none;
    }

    /* Reduce motion support (Part 9 improves this fully) */
    @media (prefers-reduced-motion: reduce){
      *{ animation-duration: .001ms !important; animation-iteration-count: 1 !important; transition-duration: .001ms !important; }
    }
  </style>
</head>

<body>
  <!-- Background -->
  <div class="bg" aria-hidden="true">
    <video id="bgVideo" autoplay muted playsinline loop preload="auto">
      <source src="assets/forest.mp4" type="video/mp4" />
    </video>
    <div class="vignette"></div>
    <div class="grain"></div>
  </div>

  <!-- FX canvas (PART 3 draws butterflies/birds/wind depth) -->
  <canvas id="fx" aria-hidden="true"></canvas>

  <!-- Nav -->
  <header class="nav">
    <div class="brand">
      <span class="dot"></span>
      <div>
        Snack Packz
        <small>Spin the globe. Pick your pack.</small>
      </div>
    </div>

    <nav class="navlinks" aria-label="Primary">
      <a href="#packs">Packs</a>
      <a href="#how">How it works</a>
      <a href="shop.html">Order</a>
    </nav>

    <div class="navRight">
      <div class="pill toggle" id="soundToggle" role="button" tabindex="0" aria-pressed="false" title="Toggle nature sound">
        Sound: <span id="soundState">Off</span>
      </div>
      <div class="pill" title="Interaction mode (enabled in Part 2)">
        Drag • Scroll • Snap
      </div>
      <a class="ctaWA" id="waBtn" href="shop.html">WhatsApp</a>
    </div>
  </header>

  <!-- Main -->
  <main class="wrap">
    <section class="hero" id="packs">
      <!-- Left cinematic panel -->
      <div class="card left">
        <div class="kickerRow">
          <div class="kicker">
            <span class="chip"><i></i> Nature Mode</span>
            <span class="chip">Hover/tap packs to preview</span>
          </div>
          <div class="kicker">
            <span class="chip">4K cinema build</span>
          </div>
        </div>

        <div>
          <h1 class="title">
            Snack Packs — <span class="accent">but rewarding.</span>
          </h1>
          <p class="desc">
            This isn’t a boring shop page. It’s a whole experience. Pick a pack, see it in motion, then lock in and order.
            Clean builds. No mess. Proper rewards.
          </p>

          <div class="ctaRow">
            <button class="btn primary" id="revealBtn">Reveal packs</button>
            <a class="btn" href="shop.html" style="text-decoration:none; display:inline-block;">Order on WhatsApp</a>
          </div>

          <!-- Orbit + dots (Part 5 makes this feel insane) -->
          <div class="orbitWrap">
            <div class="packHint">Spin • pick • preview • enter</div>
            <div class="orb" aria-hidden="true"></div>

            <div class="packDots" aria-label="Pack selector">
              <div class="packDot p1" data-pack="fresh" role="button" tabindex="0">
                <span class="miniLight"></span>
                <div>
                  <strong>FRESH</strong><br />
                  <span>Clean energy</span>
                </div>
              </div>
              <div class="packDot p2" data-pack="gaming" role="button" tabindex="0">
                <span class="miniLight"></span>
                <div>
                  <strong>GAMING</strong><br />
                  <span>Focus + fuel</span>
                </div>
              </div>
              <div class="packDot p3" data-pack="gym" role="button" tabindex="0">
                <span class="miniLight"></span>
                <div>
                  <strong>GYM</strong><br />
                  <span>Power mode</span>
                </div>
              </div>
              <div class="packDot p4" data-pack="work" role="button" tabindex="0">
                <span class="miniLight"></span>
                <div>
                  <strong>WORK</strong><br />
                  <span>Get it done</span>
                </div>
              </div>
              <div class="packDot p5" data-pack="lockin" role="button" tabindex="0">
                <span class="miniLight"></span>
                <div>
                  <strong>LOCK-IN</strong><br />
                  <span>Tunnel vision</span>
                </div>
              </div>
            </div>
          </div>

          <div class="stats" id="how">
            <div class="stat"><b>500+</b><p>Packs delivered. Clean builds, no mess.</p></div>
            <div class="stat"><b>240+</b><p>People found their go-to pack.</p></div>
            <div class="stat"><b>98%</b><p>Repeat order rate. Consistency hits.</p></div>
          </div>
        </div>
      </div>

      <!-- Right preview panel -->
      <aside class="card right" aria-label="Preview panel">
        <div class="panelHead">
          <div>
            <h3 id="panelTitle">LOCK-IN MODE</h3>
            <p id="panelDesc">Tunnel vision mode. Phone down. Get it done.</p>
          </div>
          <button class="enterBtn" id="enterBtn" type="button">Enter</button>
        </div>

        <div class="preview" id="preview">
          <div class="previewStage">
            <div class="previewContent">
              <!-- Default preview uses lockin assets (you have them already) -->
              <img id="poster" class="poster" src="assets/lockin.jpg" alt="Pack preview image" />
              <video id="dockVideo" class="dockVideo" muted playsinline loop preload="metadata"></video>

              <div class="previewHUD">
                <span class="badge"><i></i><span id="hudState">Image ready</span></span>
                <span class="badge">Hover packs to preview</span>
              </div>
            </div>
          </div>
        </div>

        <p class="hintText">
          Desktop: hover a pack to preview. Click to lock selection. Then hit Enter. Mobile: tap once to preview, tap again to enter.
        </p>

        <div class="footStrip">
          <span id="footLeft">Tip: slow mouse = smooth cinema. Fast flick = snap.</span>
          <span id="footRight">Preview: image first, then video fades in (Part 6).</span>
        </div>
      </aside>
    </section>
  </main>

  <!-- PART 1 scripts are minimal on purpose. PART 2 injects the actual motion engine. -->
  <script>
    // Pack metadata (used across Parts 2-6)
    const PACKS = {
      fresh:  { name:"FRESH",  tagline:"Clean energy",      page:"fresh.html",  poster:"assets/fresh.jpg",  video:"assets/fresh.mp4"  },
      gaming: { name:"GAMING", tagline:"Focus + fuel",      page:"gaming.html", poster:"assets/gaming.jpg", video:"assets/gaming.mp4" },
      gym:    { name:"GYM",    tagline:"Power mode",        page:"gym.html",    poster:"assets/gym.jpg",    video:"assets/gym.mp4"    },
      work:   { name:"WORK",   tagline:"Get it done",       page:"work.html",   poster:"assets/work.jpg",   video:"assets/work.mp4"   },
      lockin: { name:"LOCK-IN",tagline:"Tunnel vision mode",page:"lock-in.html",poster:"assets/lockin.jpg", video:"assets/lockin.mp4" }
    };

    // Elements
    const posterEl = document.getElementById("poster");
    const dockVideo = document.getElementById("dockVideo");
    const panelTitle = document.getElementById("panelTitle");
    const panelDesc = document.getElementById("panelDesc");
    const hudState = document.getElementById("hudState");
    const enterBtn = document.getElementById("enterBtn");

    let currentPack = "lockin";

    function setPack(packKey){
      const p = PACKS[packKey] || PACKS.lockin;
      currentPack = packKey;

      panelTitle.textContent = p.name;
      panelDesc.textContent = p.tagline;

      posterEl.src = p.poster;
      posterEl.style.opacity = 1;

      // We won't start video in Part 1 (Part 6 handles poster->video perfect).
      dockVideo.pause();
      dockVideo.removeAttribute("src");
      dockVideo.style.opacity = 0;

      hudState.textContent = "Image ready";
    }

    // Basic click selects a pack (hover logic arrives Part 6)
    document.querySelectorAll(".packDot").forEach(btn=>{
      btn.addEventListener("click", ()=> setPack(btn.dataset.pack));
      btn.addEventListener("keydown", (e)=>{
        if(e.key === "Enter" || e.key === " "){
          e.preventDefault();
          setPack(btn.dataset.pack);
        }
      });
    });

    // Enter = go to subpage
    enterBtn.addEventListener("click", ()=>{
      const p = PACKS[currentPack] || PACKS.lockin;
      window.location.href = p.page;
    });

    // Reveal button (Part 2 makes it dramatic)
    document.getElementById("revealBtn").addEventListener("click", ()=>{
      document.getElementById("packs").scrollIntoView({behavior:"smooth", block:"start"});
    });

    // FX canvas sizing stub (Part 3 draws on it)
    const fx = document.getElementById("fx");
    const ctx = fx.getContext("2d");
    function resizeFX(){
      fx.width = Math.floor(window.innerWidth * devicePixelRatio);
      fx.height = Math.floor(window.innerHeight * devicePixelRatio);
      fx.style.width = "100%";
      fx.style.height = "100%";
      ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
    }
    window.addEventListener("resize", resizeFX);
    resizeFX();

    // Sound toggle stub (Part 4 adds real ambience + birds with mobile rules)
    const soundToggle = document.getElementById("soundToggle");
    const soundState = document.getElementById("soundState");
    function setSound(on){
      soundToggle.setAttribute("aria-pressed", String(on));
      soundState.textContent = on ? "On" : "Off";
    }
    function setSound(on){
    soundToggle.setAttribute("aria-pressed", String(on));
    soundState.textContent = on ? "On" : "Off";

    if(on){
      enableAudio();
    } else {
      disableAudio();
    }
  }


<script>
  /* ============================================================
     PART 6/10 — Preview Dock Perfection
     - Poster swap instantly
     - Video preloading + cache
     - Image -> video crossfade (no black flash)
     - Desktop hover intent + click to lock
     - Mobile tap once preview, tap again enter
     ============================================================ */

  const preview = {
    current: "lockin",
    pending: null,
    hoverTimer: null,
    hoverKey: null,
    locked: false,

    // video cache: packKey -> HTMLVideoElement
    cache: new Map(),
    // limit how many videos we keep “warm”
    cacheLimit: 3,

    // crossfade control
    fadeMs: 380,
    primed: false
  };

  function setHUD(text){
    if(hudState) hudState.textContent = text;
  }

  function stopDockVideo(){
    try { dockVideo.pause(); } catch(_){}
    dockVideo.removeAttribute("src");
    dockVideo.load?.();
    dockVideo.style.opacity = 0;
  }

  function setDockPoster(packKey){
    const p = PACKS[packKey] || PACKS.lockin;
    posterEl.src = p.poster;
    posterEl.style.opacity = 1;
    setHUD("Image ready");
  }

  // Create (or reuse) a preloaded video element for pack
  function getPreloadVideo(packKey){
    const p = PACKS[packKey] || PACKS.lockin;
    if(preview.cache.has(packKey)){
      return preview.cache.get(packKey);
    }

    const v = document.createElement("video");
    v.muted = true;
    v.playsInline = true;
    v.loop = true;
    v.preload = "auto";
    v.src = p.video;
    v.crossOrigin = "anonymous"; // safe if same-origin
    v.setAttribute("playsinline", "");
    v.setAttribute("muted", "");
    v.style.display = "none";

    // Try to warm it
    const tryPlay = () => v.play().then(()=>{ v.pause(); }).catch(()=>{});
    v.addEventListener("canplay", tryPlay, { once:true });

    preview.cache.set(packKey, v);

    // cache eviction: remove oldest inserted
    if(preview.cache.size > preview.cacheLimit){
      const firstKey = preview.cache.keys().next().value;
      const firstVid = preview.cache.get(firstKey);
      try { firstVid.pause(); } catch(_){}
      firstVid.removeAttribute("src");
      preview.cache.delete(firstKey);
    }

    return v;
  }

  // Ensure the dock video element is ready to show the pack
  async function primeDockVideo(packKey){
    const p = PACKS[packKey] || PACKS.lockin;

    // If already showing same src, skip
    if(dockVideo.getAttribute("data-pack") === packKey && dockVideo.src.includes(p.video)){
      return true;
    }

    // Pull from cache / create
    const preloadV = getPreloadVideo(packKey);

    // Swap src on dock element
    dockVideo.pause();
    dockVideo.src = p.video;
    dockVideo.setAttribute("data-pack", packKey);
    dockVideo.muted = true;
    dockVideo.playsInline = true;
    dockVideo.loop = true;
    dockVideo.preload = "auto";

    // Wait for enough data to avoid black frame
    const ok = await new Promise(resolve => {
      let done = false;
      const finish = (v)=>{ if(done) return; done = true; resolve(v); };

      const t = setTimeout(()=> finish(false), 1600);

      dockVideo.addEventListener("loadeddata", ()=>{ clearTimeout(t); finish(true); }, { once:true });
      dockVideo.addEventListener("canplay",    ()=>{ clearTimeout(t); finish(true); }, { once:true });
      dockVideo.addEventListener("error",      ()=>{ clearTimeout(t); finish(false); }, { once:true });

      // Kick load
      dockVideo.load?.();
      // Attempt play (muted so allowed)
      dockVideo.play().then(()=>{}).catch(()=>{});
    });

    // Also warm preload element in background (helps future)
    try { preloadV.load?.(); } catch(_){}
    return ok;
  }

  async function crossfadeToVideo(packKey){
    setHUD("Video loading…");

    const ok = await primeDockVideo(packKey);

    if(!ok){
      // fallback: keep poster only
      stopDockVideo();
      setHUD("Image ready");
      return;
    }

    // Ensure playback running for the dock
    try { await dockVideo.play(); } catch(_){}

    // Crossfade: poster -> video
    dockVideo.style.transition = `opacity ${preview.fadeMs}ms cubic-bezier(.2,.8,.2,1)`;
    posterEl.style.transition  = `opacity ${preview.fadeMs}ms cubic-bezier(.2,.8,.2,1)`;

    dockVideo.style.opacity = 1;
    posterEl.style.opacity  = 0;

    setHUD("Video ready");
  }

  function selectPack(packKey, { lock=false, fromHover=false } = {}){
    const p = PACKS[packKey] || PACKS.lockin;
    preview.current = packKey;

    panelTitle.textContent = p.name;
    panelDesc.textContent  = p.tagline;

    // Always set poster instantly
    setDockPoster(packKey);

    // lock behaviour
    preview.locked = !!lock;
    lockedPack = lock ? packKey : lockedPack;

    // If hover preview (desktop), only fade video after short stable intent
    if(fromHover){
      // start loading but delay crossfade
      preview.pending = packKey;
      return;
    }

    // direct selection = show video quicker
    crossfadeToVideo(packKey);
  }

  /* ---------- Hover intent (premium, stable) ---------- */
  function clearPreviewHover(){
    if(preview.hoverTimer) clearTimeout(preview.hoverTimer);
    preview.hoverTimer = null;
    preview.hoverKey = null;
  }

  function schedulePreviewHover(packKey){
    if(preview.locked) return;
    clearPreviewHover();
    preview.hoverKey = packKey;

    // Immediate poster swap (fast feedback)
    selectPack(packKey, { fromHover:true });

    // After intent delay, crossfade to video if still hovered
    preview.hoverTimer = setTimeout(()=>{
      if(preview.locked) return;
      if(preview.hoverKey !== packKey) return;
      crossfadeToVideo(packKey);
    }, 160);
  }

  /* ---------- Mobile tap rules ---------- */
  function isMobileLike(){
    return (matchMedia && matchMedia("(pointer: coarse)").matches) || window.innerWidth < 820;
  }

  // Tap once = preview, tap again (same pack) = enter
  function handleMobileTap(packKey){
    if(preview.current === packKey){
      // second tap -> enter
      const p = PACKS[packKey] || PACKS.lockin;
      window.location.href = p.page;
      return;
    }
    // first tap preview
    preview.locked = true;
    lockedPack = packKey;
    selectPack(packKey, { lock:true });
  }

  /* ---------- Wire pack dots to new preview system ---------- */
  orbitDots.forEach(dot=>{
    const key = dot.dataset.pack;

    dot.addEventListener("mouseenter", ()=>{
      if(isMobileLike()) return;
      schedulePreviewHover(key);
    });

    dot.addEventListener("mouseleave", ()=>{
      if(isMobileLike()) return;
      clearPreviewHover();
    });

    dot.addEventListener("click", (e)=>{
      // Desktop: click locks selection and plays video
      if(isMobileLike()){
        handleMobileTap(key);
        return;
      }

      preview.locked = true;
      lockedPack = key;
      selectPack(key, { lock:true });

      // tiny feedback pulse
      dot.animate([
        { transform: dot.style.transform || "translate(0,0) scale(1)" },
        { transform: (dot.style.transform || "translate(0,0)") + " scale(1.03)" },
        { transform: dot.style.transform || "translate(0,0) scale(1)" }
      ], { duration: 260, easing: "cubic-bezier(.16,1,.3,1)" });
    });
  });

  // Enter button always uses current selection
  enterBtn.addEventListener("click", ()=>{
    const p = PACKS[preview.current] || PACKS.lockin;
    window.location.href = p.page;
  });

  // If user hits ESC, unlock hover again
  window.addEventListener("keydown", (e)=>{
    if(e.key.toLowerCase() === "escape"){
      preview.locked = false;
      lockedPack = null;
      clearPreviewHover();
      selectPack("lockin", { lock:false });
    }
  });

  /* ---------- Warm start (loads default pack video quietly) ---------- */
  // Call once during init (we'll hook it below safely)
  function initPreviewSystem(){
    // Ensure dockVideo has correct baseline attributes
    dockVideo.muted = true;
    dockVideo.loop = true;
    dockVideo.playsInline = true;
    dockVideo.preload = "auto";
    stopDockVideo();
    selectPack("lockin", { lock:false });
    // Warm default video a bit after first frame so it doesn't fight page load
    setTimeout(()=> {
      if(!motion.reduce) crossfadeToVideo("lockin");
    }, 420);
  }

       /* ============================================================
     PART 3/10 — Nature FX Layer (Canvas)
     - Cinematic butterflies/insects (near + mid depth)
     - Distant birds (flock arcs + parallax)
     - Wind drift + depth haze + light motes
     - Performance-safe: capped counts + adaptive quality
     ============================================================ */

  // --- Quality / performance knobs (auto-adjusts on weaker devices)
  const perf = {
    // base counts (can be reduced)
    butterflies: 18,
    insects: 26,
    motes: 22,
    birds: 10,

    // adaptive
    targetDt: 16.6,
    avgDt: 16.6,
    degrade: 0,   // 0..1
    lastAdjust: 0
  };

  // Simple heuristic for low power / mobile
  const isCoarse = matchMedia && matchMedia("(pointer: coarse)").matches;
  const isLowEnd = (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) || isCoarse;

  if(isLowEnd){
    perf.butterflies = 12;
    perf.insects = 18;
    perf.motes = 16;
    perf.birds = 7;
  }
  if(motion.reduce){
    perf.butterflies = 0;
    perf.insects = 0;
    perf.motes = 0;
    perf.birds = 0;
  }

  // --- Internal RNG (stable-ish)
  let seed = 1337;
  const rnd = () => (seed = (seed * 16807) % 2147483647) / 2147483647;
  const rndRange = (a,b) => a + (b-a)*rnd();
  const pick = (arr)=> arr[Math.floor(rnd()*arr.length)];

  // --- Canvas sizing (uses fxCanvas already set to DPR scaled; we draw in CSS pixels)
  function cw(){ return window.innerWidth; }
  function ch(){ return window.innerHeight; }

  // --- Wind field (smooth)
  const wind = { x: 0, y: 0, sx: 0, sy: 0, phase: rndRange(0,1000) };

  // --- Layers
  const layers = {
    butterflies: [],
    insects: [],
    motes: [],
    birds: []
  };

  // --- Helper: blend colors without specifying exact palette (still “nature”)
  function glowColor(kind, a){
    // Keep it subtle. No neon.
    if(kind === "lime")  return `rgba(183,255,106,${a})`;
    if(kind === "amber") return `rgba(255,216,106,${a})`;
    return `rgba(236,244,239,${a})`;
  }

  // --- Depth mapping
  function depthScale(z){
    // z: 0..1 where 0 = far, 1 = near
    return lerp(0.55, 1.25, z);
  }
  function depthAlpha(z){
    return lerp(0.10, 0.55, z);
  }
  function depthDrift(z){
    return lerp(0.25, 1.25, z);
  }

  // --- Base entity
  class Entity {
    constructor(){
      this.reset(true);
    }
    reset(initial=false){
      this.z = rndRange(0.15, 1.0);
      this.x = rndRange(-0.1, 1.1) * cw();
      this.y = rndRange(0.05, 0.95) * ch();
      this.vx = rndRange(-20, 20);
      this.vy = rndRange(-14, 14);
      this.ax = 0;
      this.ay = 0;
      this.age = initial ? rndRange(0, 10) : 0;
      this.life = rndRange(8, 20);
    }
    step(dt){
      const s = depthDrift(this.z);

      // gentle wind + parallax
      const nx = (motion.spx - 0.5) * 2;
      const ny = (motion.spy - 0.5) * 2;

      this.ax = wind.sx * (0.18 + this.z*0.55) + nx * (0.8 * (1-this.z));
      this.ay = wind.sy * (0.18 + this.z*0.55) + ny * (0.6 * (1-this.z));

      this.vx += this.ax * dt * 0.06;
      this.vy += this.ay * dt * 0.06;

      // damp
      this.vx *= 0.985;
      this.vy *= 0.985;

      this.x += this.vx * dt * 0.040 * s;
      this.y += this.vy * dt * 0.040 * s;

      this.age += dt/1000;

      // wrap with margins
      const m = 80;
      if(this.x < -m) this.x = cw() + m;
      if(this.x > cw() + m) this.x = -m;
      if(this.y < -m) this.y = ch() + m;
      if(this.y > ch() + m) this.y = -m;

      // occasional respawn to keep it fresh
      if(this.age > this.life){
        this.reset(false);
      }
    }
  }

  // --- Butterflies (stylised wings, real flutter timing)
  class Butterfly extends Entity {
    constructor(){
      super();
      this.kind = pick(["lime","amber","white"]);
      this.size = rndRange(10, 22); // base (scaled by depth)
      this.flutter = rndRange(6, 10);
      this.turn = rndRange(0, Math.PI*2);
      this.turnVel = rndRange(-1.2, 1.2);
      this.wob = rndRange(0.6, 1.4);
      this.z = rndRange(0.45, 1.0); // mostly near/mid
      this.life = rndRange(10, 22);
      this.y = rndRange(0.18, 0.88) * ch();
    }
    step(dt){
      // movement: slightly more “alive”
      this.turn += this.turnVel * dt * 0.001;
      const wander = Math.sin((performance.now()*0.001)*this.wob + this.turn) * 0.35;

      // steer with wander + micro bursts
      this.vx += Math.cos(this.turn) * dt * 0.016 + wander;
      this.vy += Math.sin(this.turn) * dt * 0.012 + wander*0.7;

      // keep them from diving off screen too much
      const mid = ch()*0.52;
      this.vy += ((mid - this.y) / ch()) * dt * 0.0009;

      super.step(dt);
    }
    draw(ctx, t){
      const s = depthScale(this.z);
      const a = depthAlpha(this.z);

      const x = this.x;
      const y = this.y;

      const flap = Math.sin(t*this.flutter + this.turn*0.7) * 0.5 + 0.5; // 0..1
      const wing = this.size * s;
      const body = wing * 0.46;

      // local parallax wobble with pointer (subtle)
      const nx = (motion.spx - 0.5) * 2;
      const ny = (motion.spy - 0.5) * 2;
      const px = nx * (6 * (1-this.z));
      const py = ny * (4 * (1-this.z));

      ctx.save();
      ctx.translate(x + px, y + py);
      ctx.rotate(this.turn * 0.35);

      // shadow blur for depth
      ctx.globalCompositeOperation = "screen";

      // Wings gradient
      const col = glowColor(this.kind, a*0.65);
      const col2 = glowColor(this.kind === "white" ? "white" : this.kind, a*0.18);

      // left wing
      ctx.save();
      ctx.scale(1, 1);
      ctx.rotate(-0.25 - flap*0.65);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-wing*0.8, -wing*0.2, -wing*1.0, wing*0.55, -wing*0.18, wing*0.75);
      ctx.bezierCurveTo(-wing*0.45, wing*0.25, -wing*0.35, -wing*0.05, 0, 0);
      ctx.closePath();
      ctx.fillStyle = col2;
      ctx.fill();

      ctx.strokeStyle = col;
      ctx.lineWidth = 1.2;
      ctx.globalAlpha = 1;
      ctx.stroke();
      ctx.restore();

      // right wing
      ctx.save();
      ctx.scale(-1, 1);
      ctx.rotate(-0.25 - flap*0.65);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.bezierCurveTo(-wing*0.8, -wing*0.2, -wing*1.0, wing*0.55, -wing*0.18, wing*0.75);
      ctx.bezierCurveTo(-wing*0.45, wing*0.25, -wing*0.35, -wing*0.05, 0, 0);
      ctx.closePath();
      ctx.fillStyle = col2;
      ctx.fill();

      ctx.strokeStyle = col;
      ctx.lineWidth = 1.2;
      ctx.stroke();
      ctx.restore();

      // body
      ctx.globalCompositeOperation = "source-over";
      ctx.globalAlpha = clamp(a*0.85, 0, 1);
      ctx.fillStyle = "rgba(0,0,0,.35)";
      ctx.beginPath();
      ctx.ellipse(0, 4, body*0.16, body*0.55, 0, 0, Math.PI*2);
      ctx.fill();

      // tiny highlight
      ctx.globalAlpha = a*0.25;
      ctx.fillStyle = glowColor("white", a*0.18);
      ctx.beginPath();
      ctx.ellipse(1.2, 2.5, body*0.10, body*0.32, 0, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }
  }

  // --- Insects (small, fast, twinkly – but not “sparkly”)
  class Insect extends Entity {
    constructor(){
      super();
      this.z = rndRange(0.25, 0.9);
      this.size = rndRange(1.2, 2.6);
      this.flicker = rndRange(10, 22);
      this.kind = pick(["lime","amber","white"]);
      this.life = rndRange(6, 14);
      this.vx = rndRange(-35, 35);
      this.vy = rndRange(-25, 25);
    }
    step(dt){
      // quick dart behaviour
      if(rnd() < 0.018){
        this.vx += rndRange(-60, 60);
        this.vy += rndRange(-50, 50);
      }
      // keep within general band
      if(this.y < ch()*0.12) this.vy += 1.2;
      if(this.y > ch()*0.92) this.vy -= 1.2;

      super.step(dt);
    }
    draw(ctx, t){
      const s = depthScale(this.z);
      const a = depthAlpha(this.z) * 0.9;

      const flick = (Math.sin(t*this.flicker + this.x*0.01) * 0.5 + 0.5);
      const alpha = a * lerp(0.25, 0.85, flick);

      const r = this.size * s;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = alpha;
      ctx.fillStyle = glowColor(this.kind, alpha*0.9);
      ctx.beginPath();
      ctx.arc(this.x, this.y, r*2.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = alpha*0.45;
      ctx.beginPath();
      ctx.arc(this.x, this.y, r*5.8, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // --- Light motes (subtle floating dust / pollen)
  class Mote extends Entity {
    constructor(){
      super();
      this.z = rndRange(0.10, 0.65);
      this.size = rndRange(1.4, 3.2);
      this.life = rndRange(14, 30);
      this.vx = rndRange(-10, 10);
      this.vy = rndRange(-6,  6);
      this.kind = pick(["white","white","amber"]);
      this.phase = rndRange(0, 1000);
    }
    step(dt){
      // slow float
      this.vx += Math.sin(performance.now()*0.0005 + this.phase) * 0.02;
      this.vy += Math.cos(performance.now()*0.0005 + this.phase) * 0.02;
      super.step(dt);
    }
    draw(ctx, t){
      const s = depthScale(this.z);
      const a = depthAlpha(this.z) * 0.55;

      const pulse = (Math.sin(t*1.8 + this.phase) * 0.5 + 0.5);
      const alpha = a * lerp(0.15, 0.60, pulse);

      const r = this.size * s;

      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.globalAlpha = alpha;
      ctx.fillStyle = glowColor(this.kind, alpha);
      ctx.beginPath();
      ctx.arc(this.x, this.y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = alpha*0.22;
      ctx.beginPath();
      ctx.arc(this.x, this.y, r*4.0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // --- Birds (distant, soft silhouettes with flock drift)
  class Bird extends Entity {
    constructor(){
      super();
      this.z = rndRange(0.05, 0.28); // far
      this.size = rndRange(10, 26);
      this.life = rndRange(18, 40);
      this.speed = rndRange(18, 34);
      this.arc = rndRange(0.8, 2.2);
      this.dir = rnd() < 0.5 ? 1 : -1;
      this.x = this.dir > 0 ? rndRange(-0.2, -0.05)*cw() : rndRange(1.05, 1.2)*cw();
      this.y = rndRange(0.10, 0.34)*ch();
      this.phase = rndRange(0, 1000);
    }
    step(dt){
      // fly across with gentle arc + parallax
      const time = performance.now()*0.00045 + this.phase;
      this.x += this.dir * this.speed * dt * 0.09;
      this.y += Math.sin(time) * this.arc * dt * 0.03;

      // tiny pointer influence (camera)
      const nx = (motion.spx - 0.5) * 2;
      const ny = (motion.spy - 0.5) * 2;
      this.x += nx * 0.10 * dt;
      this.y += ny * 0.06 * dt;

      // respawn when out
      const m = 120;
      if(this.dir > 0 && this.x > cw()+m) this.resetBird();
      if(this.dir < 0 && this.x < -m) this.resetBird();

      this.age += dt/1000;
      if(this.age > this.life) this.resetBird();
    }
    resetBird(){
      this.age = 0;
      this.life = rndRange(18, 40);
      this.speed = rndRange(18, 34);
      this.arc = rndRange(0.8, 2.2);
      this.dir = rnd() < 0.5 ? 1 : -1;
      this.x = this.dir > 0 ? rndRange(-0.2, -0.05)*cw() : rndRange(1.05, 1.2)*cw();
      this.y = rndRange(0.10, 0.34)*ch();
      this.phase = rndRange(0, 1000);
      this.z = rndRange(0.05, 0.28);
      this.size = rndRange(10, 26);
    }
    draw(ctx, t){
      const s = depthScale(this.z) * 0.7;
      const a = depthAlpha(this.z) * 0.55;

      const flap = Math.sin(t*6.0 + this.phase) * 0.5 + 0.5;
      const wing = this.size * s;

      ctx.save();
      ctx.globalAlpha = a;
      ctx.globalCompositeOperation = "source-over";
      ctx.translate(this.x, this.y);

      // silhouette (soft)
      ctx.strokeStyle = "rgba(0,0,0,.35)";
      ctx.lineWidth = 1.25;
      ctx.lineCap = "round";

      // simple “m” bird path with flap variation
      const lift = lerp(0.15, 0.55, flap);
      ctx.beginPath();
      ctx.moveTo(-wing, 0);
      ctx.quadraticCurveTo(-wing*0.35, -wing*lift, 0, 0);
      ctx.quadraticCurveTo( wing*0.35, -wing*lift, wing, 0);
      ctx.stroke();

      // faint highlight edge (very subtle)
      ctx.globalAlpha = a*0.18;
      ctx.strokeStyle = "rgba(236,244,239,.25)";
      ctx.beginPath();
      ctx.moveTo(-wing, 0);
      ctx.quadraticCurveTo(-wing*0.35, -wing*lift, 0, 0);
      ctx.quadraticCurveTo( wing*0.35, -wing*lift, wing, 0);
      ctx.stroke();

      ctx.restore();
    }
  }

  // --- Build initial populations
  function seedFX(){
    layers.butterflies.length = 0;
    layers.insects.length = 0;
    layers.motes.length = 0;
    layers.birds.length = 0;

    for(let i=0;i<perf.butterflies;i++) layers.butterflies.push(new Butterfly());
    for(let i=0;i<perf.insects;i++)     layers.insects.push(new Insect());
    for(let i=0;i<perf.motes;i++)       layers.motes.push(new Mote());
    for(let i=0;i<perf.birds;i++)       layers.birds.push(new Bird());
  }

  seedFX();

  // --- Resizing should gently reflow entities
  function onFXResizeReflow(){
    // nudge positions into current bounds
    [...layers.butterflies, ...layers.insects, ...layers.motes, ...layers.birds].forEach(e=>{
      e.x = clamp(e.x, -80, cw()+80);
      e.y = clamp(e.y, -80, ch()+80);
    });
  }

  window.addEventListener("resize", onFXResizeReflow, {passive:true});

  // --- Adaptive performance: if dt climbs, reduce counts a bit
  function adjustPerf(dt){
    perf.avgDt = lerp(perf.avgDt, dt, 0.08);

    const now = performance.now();
    if(now - perf.lastAdjust < 1200) return;
    perf.lastAdjust = now;

    // degrade on sustained slow frames
    if(perf.avgDt > 22 && perf.degrade < 1){
      perf.degrade = clamp(perf.degrade + 0.15, 0, 1);
    } else if(perf.avgDt < 17.5 && perf.degrade > 0){
      perf.degrade = clamp(perf.degrade - 0.10, 0, 1);
    }

    // Apply degrade by trimming arrays (never below minimum vibe)
    const trimTo = (arr, min, base) => {
      const target = Math.max(min, Math.floor(base * (1 - perf.degrade*0.55)));
      while(arr.length > target) arr.pop();
      while(arr.length < target){
        // re-add if improving
        const ctor = (arr === layers.butterflies) ? Butterfly :
                     (arr === layers.insects)     ? Insect :
                     (arr === layers.motes)       ? Mote : Bird;
        arr.push(new ctor());
      }
    };

    trimTo(layers.butterflies, 8,  perf.butterflies);
    trimTo(layers.insects,     10, perf.insects);
    trimTo(layers.motes,       10, perf.motes);
    trimTo(layers.birds,       5,  perf.birds);
  }

  // --- Wind update
  function stepWind(dt){
    wind.phase += dt * 0.00020;
    const time = wind.phase;

    // base wind pattern
    const wx = Math.sin(time*1.2) * 0.55 + Math.sin(time*0.35) * 0.35;
    const wy = Math.cos(time*0.9) * 0.25 + Math.sin(time*0.22) * 0.22;

    // pointer influence like “camera pushes air”
    const nx = (motion.spx - 0.5) * 2;
    const ny = (motion.spy - 0.5) * 2;

    wind.x = lerp(wind.x, wx + nx*0.35, 0.03);
    wind.y = lerp(wind.y, wy + ny*0.25, 0.03);

    // smoothed wind to use for acceleration (stable)
    wind.sx = lerp(wind.sx, wind.x, 0.06);
    wind.sy = lerp(wind.sy, wind.y, 0.06);
  }

  // --- Soft depth haze overlay (cinema atmosphere)
  function drawDepthHaze(ctx, t){
    if(motion.reduce) return;

    const w = cw(), h = ch();
    const nx = (motion.spx - 0.5) * 2;
    const ny = (motion.spy - 0.5) * 2;

    ctx.save();
    ctx.globalCompositeOperation = "screen";

    const time = t * 0.08;

    // 2-3 big soft blobs, very subtle, drifting
    for(let i=0;i<3;i++){
      const r = 320 + i*170;
      const x = w*(0.18 + i*0.22) + Math.sin(time + i*1.4) * 120 + nx*70;
      const y = h*(0.22 + i*0.10) + Math.cos(time + i*1.1) * 85  + ny*50;

      const g = ctx.createRadialGradient(x,y, 10, x,y, r);
      g.addColorStop(0, glowColor(i===1 ? "amber" : "lime", 0.030));
      g.addColorStop(0.55, glowColor("white", 0.012));
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y,r,0,Math.PI*2);
      ctx.fill();
    }

    ctx.restore();
  }

  // --- NEW drawFX(dt) (this replaces Part 2 stub)
  function drawFX(dt){
    adjustPerf(dt);
    stepWind(dt);

    const w = cw(), h = ch();
    fxCtx.clearRect(0,0,w,h);

    if(motion.reduce) return;

    const t = performance.now() * 0.001;

    // Depth haze FIRST (behind entities)
    drawDepthHaze(fxCtx, t);

    // Draw order: far birds -> motes -> insects -> butterflies (depth vibe)
    // Birds
    for(const b of layers.birds){
      b.step(dt);
      b.draw(fxCtx, t);
    }

    // Motes
    fxCtx.globalCompositeOperation = "screen";
    for(const m of layers.motes){
      m.step(dt);
      m.draw(fxCtx, t);
    }

    // Insects (fast twinkles)
    for(const ins of layers.insects){
      ins.step(dt);
      ins.draw(fxCtx, t);
    }

    // Butterflies (hero layer)
    fxCtx.globalCompositeOperation = "source-over";
    for(const bf of layers.butterflies){
      bf.step(dt);
      bf.draw(fxCtx, t);
    }

    // tiny “wind streak” hint occasionally (super subtle)
    if(perf.degrade < 0.6 && rnd() < 0.05){
      const nx = (motion.spx - 0.5) * 2;
      fxCtx.save();
      fxCtx.globalAlpha = 0.06;
      fxCtx.strokeStyle = "rgba(236,244,239,.20)";
      fxCtx.lineWidth = 1;
      fxCtx.beginPath();
      const y = h*rndRange(0.12, 0.92);
      const len = rndRange(50, 120);
      const x0 = w*rndRange(0.05, 0.95);
      fxCtx.moveTo(x0, y);
      fxCtx.quadraticCurveTo(x0 + len*0.55, y - 6 - nx*6, x0 + len, y + 2 + nx*5);
      fxCtx.stroke();
      fxCtx.restore();
    }
  }

  /* ============================================================
     END PART 3 BLOCK
     ============================================================ */

  
      rafId = requestAnimationFrame(tick);
    }
  
    /* -----------------------
       Init
       ----------------------- */
    /* ============================================================
     PART 5/10 — Pack Orbit Physics
     - Drag + scroll inertia
     - Weighted spin
     - Snap-to-pack logic
     - Feels physical, not UI
     ============================================================ */

  const orbit = {
    angle: 0,           // current rotation (rad)
    velocity: 0,        // angular velocity
    targetAngle: null,  // snap target
    radius: 0,          // computed from layout
    friction: 0.94,
    snapStrength: 0.12,
    dragging: false,
    lastX: 0
  };

  const orbitWrap = document.querySelector(".orbitWrap");
  const orbitDots = [...document.querySelectorAll(".packDot")];

  const packOrder = orbitDots.map(d => d.dataset.pack);

  function layoutOrbit(){
    const rect = orbitWrap.getBoundingClientRect();
    orbit.radius = Math.min(rect.width, rect.height) * 0.42;
  }

  function packAngle(index){
    return (index / packOrder.length) * Math.PI * 2;
  }

  function normalizeAngle(a){
    while(a < -Math.PI) a += Math.PI * 2;
    while(a >  Math.PI) a -= Math.PI * 2;
    return a;
  }

  function snapToNearest(){
    let best = 0;
    let min = Infinity;

    packOrder.forEach((_, i)=>{
      const a = normalizeAngle(orbit.angle - packAngle(i));
      const d = Math.abs(a);
      if(d < min){
        min = d;
        best = i;
      }
    });

    orbit.targetAngle = packAngle(best);
    lockedPack = packOrder[best];
    setPack(lockedPack);
  }

  /* ---------- Drag / Scroll Input ---------- */

  orbitWrap.addEventListener("pointerdown", e=>{
    orbit.dragging = true;
    orbit.lastX = e.clientX;
    orbit.velocity = 0;
    orbit.targetAngle = null;
    orbitWrap.setPointerCapture(e.pointerId);
  });

  window.addEventListener("pointerup", ()=>{
    if(!orbit.dragging) return;
    orbit.dragging = false;
    snapToNearest();
  });

  window.addEventListener("pointermove", e=>{
    if(!orbit.dragging) return;
    const dx = e.clientX - orbit.lastX;
    orbit.lastX = e.clientX;

    orbit.velocity += dx * 0.0009;
  });

  // Scroll wheel flick
  orbitWrap.addEventListener("wheel", e=>{
    e.preventDefault();
    orbit.velocity += e.deltaY * -0.00025;
    orbit.targetAngle = null;
  }, { passive:false });

  /* ---------- Positioning ---------- */

  function updateOrbit(dt){
    // inertia
    orbit.angle += orbit.velocity;
    orbit.velocity *= orbit.friction;

    // snap if target exists
    if(orbit.targetAngle !== null){
      const diff = normalizeAngle(orbit.targetAngle - orbit.angle);
      orbit.velocity += diff * orbit.snapStrength;
    }

    // place dots
    orbitDots.forEach((dot, i)=>{
      const a = orbit.angle + packAngle(i);
      const x = Math.cos(a) * orbit.radius;
      const y = Math.sin(a) * orbit.radius * 0.72;

      // depth illusion
      const z = (Math.sin(a) + 1) * 0.5;
      const scale = lerp(0.78, 1.15, z);
      const alpha = lerp(0.45, 1.0, z);

      dot.style.transform =
        `translate(${x}px, ${y}px) scale(${scale})`;

      dot.style.opacity = alpha;
      dot.style.zIndex = Math.floor(z * 100);
    });
  }

  /* ---------- Hook into main RAF ---------- */

  const _applyParallax = applyParallax;
  applyParallax = function(dt){
    _applyParallax(dt);
    updateOrbit(dt);
  };

      /* ============================================================
     PART 7/10 — Micro-interactions (append-only)
     - Magnetic “real” buttons (stronger + smoother)
     - Cinematic press ripple (subtle, not cheap)
     - Focus glow (premium accessibility)
     - Pack breathing + depth shimmer tied to motion
     ============================================================ */

  function addRipple(el){
    if(!el) return;
    el.style.position = el.style.position || "relative";
    el.style.overflow = "hidden";

    el.addEventListener("pointerdown", (e)=>{
      const r = el.getBoundingClientRect();
      const x = (e.clientX - r.left);
      const y = (e.clientY - r.top);
      const size = Math.max(r.width, r.height) * 1.15;

      const ripple = document.createElement("span");
      ripple.style.position = "absolute";
      ripple.style.left = (x - size/2) + "px";
      ripple.style.top  = (y - size/2) + "px";
      ripple.style.width = size + "px";
      ripple.style.height = size + "px";
      ripple.style.borderRadius = "999px";
      ripple.style.pointerEvents = "none";
      ripple.style.opacity = "0.0";
      ripple.style.transform = "scale(0.65)";
      ripple.style.filter = "blur(0.2px)";
      ripple.style.background = "radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), rgba(183,255,106,.14) 35%, rgba(0,0,0,0) 72%)";

      el.appendChild(ripple);

      ripple.animate([
        { opacity: 0.0, transform: "scale(0.55)" },
        { opacity: 0.38, transform: "scale(1.0)" },
        { opacity: 0.0, transform: "scale(1.12)" }
      ], { duration: 520, easing: "cubic-bezier(.16,1,.3,1)" }).onfinish = () => ripple.remove();
    }, { passive:true });
  }

  function addFocusGlow(el){
    if(!el) return;
    el.addEventListener("focus", ()=>{
      el.style.boxShadow = "0 0 0 1px rgba(255,255,255,.14), 0 18px 55px rgba(183,255,106,.10)";
      el.style.borderColor = "rgba(255,255,255,.22)";
    });
    el.addEventListener("blur", ()=>{
      el.style.boxShadow = "";
      el.style.borderColor = "";
    });
  }

  // Pack “breathing” + shimmer that follows the camera
  function tickMicro(){
    if(motion.reduce) return;

    const t = performance.now() * 0.001;
    const nx = (motion.spx - 0.5) * 2;
    const ny = (motion.spy - 0.5) * 2;

    // make front-most pack feel alive (uses zIndex set in Part 5)
    let topDot = null;
    let topZ = -Infinity;
    orbitDots.forEach(d=>{
      const z = Number(d.style.zIndex || 0);
      if(z > topZ){ topZ = z; topDot = d; }
    });

    orbitDots.forEach(d=>{
      const isTop = (d === topDot);
      const breathe = 1 + (isTop ? (Math.sin(t*1.6) * 0.012) : (Math.sin(t*1.1 + topZ) * 0.006));

      // subtle highlight sweep (not neon)
      const sheen = clamp(0.06 + (nx*0.04) + (isTop ? 0.04 : 0.0), 0.03, 0.14);
      d.style.background = `rgba(8,14,10,${0.26 + sheen})`;
      d.style.borderColor = isTop ? "rgba(255,255,255,.22)" : "rgba(255,255,255,.14)";

      // keep existing orbit transform and multiply a tiny breathe
      const base = d.style.transform || "";
      // only append if we haven't already appended
      if(!base.includes(" scale(")){
        // Part 5 already has scale; just add a tiny extra via CSS variable-ish trick
        d.style.transform = base + ` scale(${breathe.toFixed(4)})`;
      } else {
        // If Part 5 already sets scale, we don't want to stack infinitely.
        // So we reapply a gentle final scale via a shadow only.
        d.style.boxShadow = isTop
          ? "0 18px 45px rgba(0,0,0,.45), 0 0 0 1px rgba(183,255,106,.10)"
          : "0 14px 35px rgba(0,0,0,.35)";
      }
    });

    // Preview glass shimmer follows pointer
    if(previewEl){
      const px = nx * 10;
      const py = ny * 8;
      previewEl.style.boxShadow = `0 18px 60px rgba(0,0,0,.45), ${px}px ${py}px 55px rgba(183,255,106,.06)`;
    }

    requestAnimationFrame(tickMicro);
  }

  function initMicro(){
    // Ripple + focus glow on key controls
    [enterBtn, revealBtn, soundToggle].forEach(el=>{
      addRipple(el);
      addFocusGlow(el);
    });

    // Make pack dots feel “pressable”
    orbitDots.forEach(d=>{
      addFocusGlow(d);
      addRipple(d);
    });

    requestAnimationFrame(tickMicro);
  }

      /* ============================================================
     PART 8/10 — Performance + 4K Quality Control (append-only)
     - Adaptive quality when dt rises
     - FX throttling on low power / hidden tab
     - Background video resolution sanity
     - Preview warm-up scheduling
     ============================================================ */

  const perfCtl = {
    // quality: 1 = full cinema, 0 = minimal
    q: 1,
    targetQ: 1,
    lastT: performance.now(),
    avgDt: 16.6,
    hidden: document.hidden,
    lowPower: false,

    // FX throttle: draw every N frames at lower quality
    fxEvery: 1,
    fxFrame: 0,

    // background throttles
    bgRate: 1.0,     // playbackRate
    bgScale: 1.05    // transform scale
  };

  function detectLowPower(){
    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const small = window.innerWidth < 820;
    const cores = navigator.hardwareConcurrency || 8;

    // user agents vary; keep this simple + safe
    perfCtl.lowPower = motion.reduce || coarse || small || cores <= 4;
  }

  function setBackgroundQuality(){
    if(!bgVideo) return;

    // Reduce decoding load on low power
    bgVideo.playbackRate = perfCtl.bgRate;

    // Keep the “cinema push-in” but avoid GPU thrash
    // (applyParallax sets translate; we set scale target)
    bgVideo.style.willChange = perfCtl.q > 0.6 ? "transform, filter" : "transform";

    // Slightly reduce grade when low power (helps some devices)
    if(perfCtl.q < 0.6){
      bgVideo.style.filter = "contrast(1.08) saturate(1.10) brightness(.84)";
    } else {
      bgVideo.style.filter = "contrast(1.12) saturate(1.14) brightness(.82)";
    }
  }

  function setFXThrottle(){
    // throttle canvas drawing without killing motion engine
    if(perfCtl.q > 0.85) perfCtl.fxEvery = 1;
    else if(perfCtl.q > 0.65) perfCtl.fxEvery = 2;
    else if(perfCtl.q > 0.45) perfCtl.fxEvery = 3;
    else perfCtl.fxEvery = 4;
  }

  function updatePerf(dt){
    // rolling avg
    perfCtl.avgDt = lerp(perfCtl.avgDt, dt, 0.06);

    // compute a target quality from avg dt
    // > 24ms means struggling, < 18ms means healthy
    if(perfCtl.hidden){
      perfCtl.targetQ = 0.25;
    } else if(perfCtl.lowPower){
      // low power prefers stable
      if(perfCtl.avgDt > 22) perfCtl.targetQ = 0.40;
      else if(perfCtl.avgDt > 19) perfCtl.targetQ = 0.55;
      else perfCtl.targetQ = 0.70;
    } else {
      if(perfCtl.avgDt > 26) perfCtl.targetQ = 0.35;
      else if(perfCtl.avgDt > 22) perfCtl.targetQ = 0.55;
      else if(perfCtl.avgDt > 19) perfCtl.targetQ = 0.75;
      else perfCtl.targetQ = 1.00;
    }

    // smooth quality changes
    perfCtl.q = lerp(perfCtl.q, perfCtl.targetQ, 0.05);

    // apply derived throttles
    setFXThrottle();

    // background decoding load tweaks
    if(perfCtl.hidden){
      perfCtl.bgRate = 0.6;
      perfCtl.bgScale = 1.02;
    } else if(perfCtl.lowPower && perfCtl.q < 0.6){
      perfCtl.bgRate = 0.85;
      perfCtl.bgScale = 1.03;
    } else {
      perfCtl.bgRate = 1.0;
      perfCtl.bgScale = 1.05;
    }

    setBackgroundQuality();
  }

  // Wrap drawFX to throttle without rewriting your engine
  const _drawFX = drawFX;
  drawFX = function(dt){
    if(motion.reduce) return;

    perfCtl.fxFrame++;
    if(perfCtl.fxEvery > 1 && (perfCtl.fxFrame % perfCtl.fxEvery) !== 0){
      return; // skip this frame's FX
    }
    _drawFX(dt);
  };

  // Wrap tick to update perf each frame (append-only safe)
  const _tick = tick;
  tick = function(t){
    const dt = Math.min(40, t - lastT);
    // keep your original time updates
    // (lastT is in outer scope already; use as-is)
    updatePerf(dt);
    _tick(t);
  };

  function warmPreviewCache(){
    // Warm a couple pack videos in background AFTER the page settles.
    // Prevents "first hover = delay".
    if(motion.reduce) return;

    const warmList = ["lockin","fresh","gym","gaming","work"];
    let i = 0;

    const step = () => {
      if(i >= warmList.length) return;
      const key = warmList[i++];
      try { getPreloadVideo(key); } catch(_){}
      // schedule with idle time
      setTimeout(step, perfCtl.lowPower ? 900 : 520);
    };

    setTimeout(step, perfCtl.lowPower ? 1400 : 900);
  }

  function initPerf(){
    detectLowPower();
    window.addEventListener("resize", detectLowPower, {passive:true});

    document.addEventListener("visibilitychange", ()=>{
      perfCtl.hidden = document.hidden;
      if(perfCtl.hidden){
        // if hidden, ease off GPU load a bit
        if(bgVideo) bgVideo.pause();
      } else {
        if(bgVideo) bgVideo.play().catch(()=>{});
      }
    });

    setBackgroundQuality();
    warmPreviewCache();
  }

      /* ============================================================
     PART 9/10 — Mobile + A11y + Fallback (append-only)
     - Tap targets + mobile affordances
     - Reduced-motion that still feels premium
     - Video play fallback (bg + dock)
     - Keyboard + focus improvements
     ============================================================ */

  const a11y = {
    coarse: matchMedia && matchMedia("(pointer: coarse)").matches,
    reduced: motion.reduce,
    videoOk: true,
    dockVideoOk: true
  };

  function addMobileClass(){
    const mobileLike = a11y.coarse || window.innerWidth < 820;
    document.documentElement.classList.toggle("mobile", mobileLike);
  }

  function ensureHitTargets(){
    // Make small controls easier on mobile without changing layout
    if(!(a11y.coarse || window.innerWidth < 820)) return;

    // pack dots: increase padding slightly via inline styles
    orbitDots.forEach(d=>{
      d.style.minHeight = "56px";
      d.style.minWidth = "168px";
    });

    // nav pills: a bit taller
    [soundToggle].forEach(el=>{
      if(!el) return;
      el.style.padding = "12px 14px";
    });
  }

  function safePlay(videoEl){
    if(!videoEl) return Promise.resolve(false);
    return videoEl.play().then(()=>true).catch(()=>false);
  }

  async function verifyBackgroundVideo(){
    if(!bgVideo) return;
    // Some browsers block even muted play until gesture (rare but happens)
    const ok = await safePlay(bgVideo);
    if(!ok){
      a11y.videoOk = false;
      // fallback: freeze on first frame, keep cinema look via filters
      bgVideo.pause();
      bgVideo.removeAttribute("autoplay");
      // If the element fails to decode at all, hide it
      setTimeout(()=>{
        if(bgVideo.readyState < 2){
          bgVideo.style.display = "none";
          // fallback background gradient still exists via .bg container
          document.querySelector(".bg").style.background =
            "radial-gradient(1200px 700px at 20% 15%, rgba(183,255,106,.06), rgba(0,0,0,.78) 60%, rgba(0,0,0,.92))";
        }
      }, 800);
    }
  }

  async function verifyDockVideo(){
    if(!dockVideo) return;
    // Dock is always muted; should be allowed after gesture, but we handle no-support
    const ok = await safePlay(dockVideo);
    if(!ok){
      a11y.dockVideoOk = false;
      // Keep poster only, permanently
      stopDockVideo();
      setHUD("Image only");
    } else {
      dockVideo.pause(); // don’t force-play yet
    }
  }

  function reducedMotionPolish(){
    if(!a11y.reduced) return;

    // Keep it premium: remove heavy parallax/rotation but keep crisp layout
    cards.forEach(c=>{
      c.style.transform = "translateZ(0)";
      c.style.willChange = "auto";
    });

    if(bgVideo){
      bgVideo.style.transform = "scale(1.03)";
      bgVideo.style.filter = "contrast(1.10) saturate(1.10) brightness(.84)";
    }

    // Turn off FX entirely (Part 8 throttle already helps, but this is explicit)
    try {
      fxCtx.clearRect(0,0,window.innerWidth,window.innerHeight);
    } catch(_){}
  }

  function addKeyboardHints(){
    // Make Enter/Space behaviour clearer without adding visible clutter
    // Adds title attributes for desktop discoverability
    orbitDots.forEach(d=>{
      const key = d.dataset.pack;
      const p = PACKS[key] || PACKS.lockin;
      d.setAttribute("title", `Preview ${p.name} • Click to lock • Enter to open`);
      d.setAttribute("role", "button");
      d.setAttribute("tabindex", "0");
    });

    enterBtn?.setAttribute("title", "Open selected pack (Enter)");
    previewEl?.setAttribute("title", "Pack preview: image then video");
  }

  function reinforceMobileBehaviour(){
    // On mobile, we want the user to KNOW tap once previews
    if(!(a11y.coarse || window.innerWidth < 820)) return;

    const footLeft = document.getElementById("footLeft");
    const footRight = document.getElementById("footRight");
    if(footLeft) footLeft.textContent = "Mobile tip: tap a pack once to preview.";
    if(footRight) footRight.textContent = "Tap the same pack again to enter.";
  }

  // Make focus rings not ugly: add a gentle outline only when keyboard is used
  function focusVisiblePolish(){
    let keyboardMode = false;
    window.addEventListener("keydown", ()=>{ keyboardMode = true; }, {passive:true});
    window.addEventListener("pointerdown", ()=>{ keyboardMode = false; }, {passive:true});

    const style = document.createElement("style");
    style.textContent = `
      :focus { outline: none; }
      .kb :focus-visible {
        outline: 2px solid rgba(183,255,106,.55);
        outline-offset: 3px;
        border-radius: 14px;
      }
    `;
    document.head.appendChild(style);

    // toggle class
    setInterval(()=>{
      document.documentElement.classList.toggle("kb", keyboardMode);
    }, 250);
  }

  function initA11yMobile(){
    addMobileClass();
    ensureHitTargets();
    addKeyboardHints();
    reinforceMobileBehaviour();
    focusVisiblePolish();
    reducedMotionPolish();

    // Verify video ability after first gesture (more reliable)
    const verify = async () => {
      await verifyBackgroundVideo();
      // Dock video will be verified when user triggers previews anyway
    };

    // Run now and also after the first interaction
    verify();
    ["pointerdown","touchstart","keydown"].forEach(evt=>{
      window.addEventListener(evt, verify, { once:true, passive:true });
    });

    window.addEventListener("resize", ()=>{
      a11y.coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
      addMobileClass();
      ensureHitTargets();
      reinforceMobileBehaviour();
    }, {passive:true});
  }

      /* ============================================================
     PART 10/10 — Final Polish (append-only)
     - Cinematic intro settle
     - Ultra-light film grain + vignette
     - Premium copy + pack naming
     - Confidence lock after selection
     ============================================================ */

  const finalPolish = {
    introDone: false,
    grainCanvas: null,
    grainCtx: null,
    grainStrength: 0.045
  };

  /* ---------- Cinematic intro settle ---------- */
  function introSettle(){
    // Prevent immediate chaos on load; let the scene “land”
    let t = 0;
    const dur = 1200;
    const start = performance.now();

    function step(now){
      t = clamp((now - start) / dur, 0, 1);
      const ease = t*t*(3-2*t); // smoothstep

      // Gently ramp parallax + FX
      motion.spx = lerp(0.5, motion.spx, ease);
      motion.spy = lerp(0.5, motion.spy, ease);

      if(bgVideo){
        bgVideo.style.filter =
          `contrast(${lerp(1.04,1.12,ease)}) saturate(${lerp(1.06,1.14,ease)}) brightness(${lerp(.90,.82,ease)})`;
      }

      if(t < 1){
        requestAnimationFrame(step);
      } else {
        finalPolish.introDone = true;
      }
    }
    requestAnimationFrame(step);
  }

  /* ---------- Film grain + vignette (canvas overlay) ---------- */
  function initGrain(){
    if(motion.reduce) return;

    const c = document.createElement("canvas");
    c.style.position = "fixed";
    c.style.inset = "0";
    c.style.pointerEvents = "none";
    c.style.zIndex = "6";
    c.style.mixBlendMode = "overlay";
    document.body.appendChild(c);

    finalPolish.grainCanvas = c;
    finalPolish.grainCtx = c.getContext("2d");

    function resize(){
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      c.width  = Math.floor(window.innerWidth * dpr);
      c.height = Math.floor(window.innerHeight * dpr);
      c.style.width = "100%";
      c.style.height = "100%";
      finalPolish.grainCtx.setTransform(dpr,0,0,dpr,0,0);
    }
    resize();
    window.addEventListener("resize", resize, {passive:true});

    function drawGrain(){
      const ctx = finalPolish.grainCtx;
      if(!ctx) return;

      ctx.clearRect(0,0,window.innerWidth,window.innerHeight);

      // Grain
      const img = ctx.createImageData(window.innerWidth, window.innerHeight);
      const d = img.data;
      for(let i=0;i<d.length;i+=4){
        const n = (Math.random()*255)|0;
        d[i] = d[i+1] = d[i+2] = n;
        d[i+3] = Math.floor(finalPolish.grainStrength * 255);
      }
      ctx.putImageData(img,0,0);

      // Vignette
      const g = ctx.createRadialGradient(
        window.innerWidth/2, window.innerHeight/2, Math.min(window.innerWidth,window.innerHeight)*0.25,
        window.innerWidth/2, window.innerHeight/2, Math.max(window.innerWidth,window.innerHeight)*0.75
      );
      g.addColorStop(0,"rgba(0,0,0,0)");
      g.addColorStop(1,"rgba(0,0,0,.35)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,window.innerWidth,window.innerHeight);

      requestAnimationFrame(drawGrain);
    }
    requestAnimationFrame(drawGrain);
  }

  /* ---------- Premium copy polish ---------- */
  function polishCopy(){
    // Subtle copy refinements without changing structure
    const map = {
      fresh:  "Clean energy. Zero noise.",
      gaming: "Locked focus. Long sessions.",
      gym:    "Explosive drive. Controlled burn.",
      work:   "Calm clarity. Get it done.",
      lockin: "Tunnel vision. No distractions.",
      mystery:"Unbox the unexpected."
    };

    Object.keys(PACKS).forEach(k=>{
      if(map[k]) PACKS[k].tagline = map[k];
    });
  }

  /* ---------- Confidence lock ---------- */
  function confidenceLock(){
    // After a pack is locked for a moment, reduce micro jitter
    let lastLock = null;
    setInterval(()=>{
      if(lockedPack && lockedPack !== lastLock){
        lastLock = lockedPack;
        // After short delay, damp motion a bit
        setTimeout(()=>{
          if(lockedPack === lastLock){
            motion.vx *= 0.25;
            motion.vy *= 0.25;
            orbit.velocity *= 0.35;
          }
        }, 420);
      }
    }, 200);
  }

  function initFinalPolish(){
    polishCopy();
    introSettle();
    initGrain();
    confidenceLock();
  }

  /* ---------- Init Orbit ---------- */

  function initOrbit(){
    layoutOrbit();
    window.addEventListener("resize", layoutOrbit);
  }

  initOrbit();

    function init(){
      setFXSize();
      window.addEventListener("resize", setFXSize);
  
      // Magnetic UI for the “expensive” feel
      magnet(enterBtn, 0.11);
      magnet(revealBtn, 0.10);

      initMicro();
      initPerf();
      initA11yMobile();
      initFinalPolish();

      // set default pack
      setPack("lockin");
  
      // Safety: background video on some browsers needs play() attempt
      if(bgVideo){
        const tryPlay = () => bgVideo.play().catch(()=>{});
        tryPlay();
        document.addEventListener("visibilitychange", ()=>{
          if(!document.hidden) tryPlay();
        });
      }
  
      // Start RAF
      rafId = requestAnimationFrame(tick);
    }
  
    init();
  
  })();
  </script>
  
  
