<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Snack Packz — 3D Forest</title>
  <meta name="theme-color" content="#050705"/>

  <style>
    :root{
      --fg:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.72);
      --dim:rgba(255,255,255,.52);
      --accent:rgba(205,255,140,.92);
      --ease:cubic-bezier(.16,1,.3,1);
      --shadow: 0 30px 110px rgba(0,0,0,.70);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:#030403;
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }

    #stage{ position:fixed; inset:0; z-index:0; background:#020302; }

    #topbar{
      position:fixed; left:18px; right:18px; top:16px;
      display:flex; align-items:center; justify-content:space-between;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      z-index:50;
      user-select:none;
    }
    .brand{ display:flex; gap:10px; align-items:center; }
    .seed{
      width:10px; height:10px; border-radius:999px;
      background: radial-gradient(circle at 30% 30%, #fff, rgba(255,255,255,.18) 35%, var(--accent) 72%, rgba(0,0,0,0));
      box-shadow: 0 0 0 7px rgba(205,255,140,.08);
    }
    .brand b{ font-weight:950; letter-spacing:.2px; }
    .brand small{ display:block; color:var(--dim); font-weight:700; margin-top:2px; }

    .controls{ display:flex; gap:10px; align-items:center; }
    .pill{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.24);
      color: var(--fg);
      padding:10px 12px;
      border-radius: 999px;
      font-weight:900;
      cursor:pointer;
      text-decoration:none;
      user-select:none;
      transition: transform .25s var(--ease), background .25s var(--ease), border-color .25s var(--ease);
      white-space:nowrap;
    }
    .pill:hover{ transform: translateY(-1px); background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.20); }
    .pill.cta{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.30); }

    #hint{
      position:fixed; left:50%; transform:translateX(-50%);
      top: 94px;
      padding:10px 12px;
      border-radius:999px;
      background: rgba(0,0,0,.22);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      display:flex; gap:10px; align-items:center;
      user-select:none;
      z-index:50;
    }
    #hint .k{ font-weight:950; }
    #hint .s{ color:var(--muted); font-weight:800; }

    #dock{
      position:fixed; left:18px; right:18px; bottom:16px;
      display:flex; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-radius:999px;
      background: rgba(0,0,0,.26);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      user-select:none;
      z-index:50;
    }
    .chips{ display:flex; gap:10px; align-items:center; }
    .chip{
      padding:9px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.76);
      font-weight:900;
      font-size:12px;
      white-space:nowrap;
    }

    #crosshair{
      position:fixed; left:50%; top:50%;
      width:10px; height:10px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: rgba(255,255,255,.78);
      box-shadow: 0 0 0 10px rgba(255,255,255,.05);
      mix-blend-mode: screen;
      pointer-events:none;
      z-index:60;
    }

    #minimapHUD{
      position: fixed;
      right: 18px;
      bottom: 86px;
      width: 240px;
      border-radius: 22px;
      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      padding: 10px;
      z-index: 60;
      user-select: none;
    }
    #minimapHUD .mmTop{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
      padding: 4px 6px 8px;
    }
    #minimapHUD .mmTop b{ letter-spacing:.9px; font-weight:950; }
    #minimapHUD .mmHint{ color: rgba(255,255,255,.62); font-weight:850; font-size: 11px; }
    #minimapHUD canvas{
      width: 220px; height: 220px;
      display:block;
      border-radius: 18px;
    }
    #minimapHUD .mmBottom{
      display:flex; gap:8px; flex-wrap:wrap;
      padding: 8px 6px 2px;
    }
    #minimapHUD .mmChip{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.22);
      border-radius: 999px;
      padding: 7px 10px;
      font-weight:900;
      font-size: 12px;
      color: rgba(255,255,255,.78);
    }

    #menu{
      position:fixed; inset:0; z-index:80;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(12px);
      padding:18px;
    }
    #menuCard{
      width:min(520px, 94vw);
      border-radius:26px;
      background: rgba(0,0,0,.42);
      border:1px solid rgba(255,255,255,.12);
      box-shadow: var(--shadow);
      padding:16px;
    }
    #menuCard h2{ margin:6px 6px 10px; font-size:18px; letter-spacing:.2px; }
    #menuCard p{ margin:0 6px 14px; color: rgba(255,255,255,.70); font-weight:750; line-height:1.3; }
    .menuRow{ display:flex; gap:10px; flex-wrap:wrap; padding:6px; }
    .menuBtn{
      flex:1; min-width: 140px;
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      padding:12px 12px;
      background: rgba(255,255,255,.08);
      color: var(--fg);
      font-weight:950;
      cursor:pointer;
    }
    .menuBtn.primary{ background: rgba(255,255,255,.90); color:#070a08; border-color: rgba(255,255,255,.25); }

    #mobileUI{
      position:fixed; left:0; right:0; bottom:0;
      padding:18px;
      display:none;
      justify-content:space-between;
      align-items:flex-end;
      gap:14px;
      z-index:90;
      pointer-events:none;
    }
    #joy{
      width:140px; height:140px;
      border-radius:999px;
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      backdrop-filter: blur(10px);
      position:relative;
      pointer-events:auto;
      touch-action:none;
    }
    #joyKnob{
      width:56px; height:56px;
      border-radius:999px;
      position:absolute;
      left:50%; top:50%;
      transform: translate(-50%,-50%);
      background: rgba(255,255,255,.86);
      box-shadow: 0 18px 70px rgba(255,255,255,.12);
    }
    #useBtn{
      pointer-events:auto;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.90);
      color:#070a08;
      font-weight:950;
      border-radius: 18px;
      padding:16px 18px;
      min-width: 110px;
    }

    @media (pointer:coarse), (max-width: 820px){
      #mobileUI{ display:flex; }
      #minimapHUD{ display:none; }
    }
  </style>
</head>

<body>
  <canvas id="stage"></canvas>

  <header id="topbar">
    <div class="brand">
      <span class="seed"></span>
      <div>
        <b>Snack Packz</b>
        <small>Click to lock • WASD move • Q/E turn • F enter • Esc menu</small>
      </div>
    </div>
    <div class="controls">
      <button id="exitBtn" class="pill" type="button">Exit</button>
      <button id="qualityBtn" class="pill" type="button" aria-pressed="true">Quality: Ultra</button>
      <a class="pill cta" href="shop.html">Order</a>
    </div>
  </header>

  <div id="hint">
    <div class="k">Click to lock</div>
    <div class="s">Aim at a totem → screen plays video. Walk up → F enters.</div>
  </div>

  <div id="dock">
    <div>
      <b id="dockTitle">Forest Clearing</b><br/>
      <small id="dockSub" style="color:rgba(255,255,255,.72);font-weight:750;">Find a totem.</small>
    </div>
    <div class="chips">
      <span class="chip" id="fpsChip">FPS: --</span>
      <span class="chip" id="stateChip">Click to lock</span>
    </div>
  </div>

  <div id="crosshair"></div>

  <div id="minimapHUD" aria-hidden="true">
    <div class="mmTop">
      <b>MAP</b>
      <span class="mmHint">Clearing boundaries.</span>
    </div>
    <canvas id="mm" width="220" height="220"></canvas>
    <div class="mmBottom">
      <span class="mmChip" id="mmPos">x 0.0 • z 0.0</span>
      <span class="mmChip" id="mmNear">Nearest: —</span>
    </div>
  </div>

  <div id="mobileUI" aria-hidden="true">
    <div id="joy"><div id="joyKnob"></div></div>
    <button id="useBtn" type="button">USE</button>
  </div>

  <div id="menu" aria-hidden="true">
    <div id="menuCard">
      <h2>Pause Menu</h2>
      <p>Resume, reset, or leave the forest.</p>
      <div class="menuRow">
        <button id="resumeBtn" class="menuBtn primary" type="button">Resume</button>
        <button id="resetBtn" class="menuBtn" type="button">Reset position</button>
        <button id="leaveBtn" class="menuBtn" type="button">Leave game</button>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";

    // ===== Packs =====
    const PACKS = [
      { key:"fresh",  name:"FRESH",   tag:"Clean energy. Zero noise.",        page:"fresh.html",   poster:"assets/fresh.jpg",   video:"assets/fresh.mp4" },
      { key:"gaming", name:"GAMING",  tag:"Locked focus. Long sessions.",      page:"gaming.html",  poster:"assets/gaming.jpg",  video:"assets/gaming.mp4" },
      { key:"gym",    name:"GYM",     tag:"Explosive drive. Controlled burn.", page:"gym.html",     poster:"assets/gym.jpg",     video:"assets/gym.mp4" },
      { key:"work",   name:"WORK",    tag:"Calm clarity. Get it done.",        page:"work.html",    poster:"assets/work.jpg",    video:"assets/work.mp4" },
      { key:"lockin", name:"LOCK-IN", tag:"Tunnel vision. No distractions.",   page:"lock-in.html", poster:"assets/lockin.jpg",  video:"assets/lockin.mp4" }
    ];

    // ===== UI =====
    const canvas = document.getElementById("stage");
    const exitBtn = document.getElementById("exitBtn");
    const qualityBtn = document.getElementById("qualityBtn");
    const dockTitle = document.getElementById("dockTitle");
    const dockSub = document.getElementById("dockSub");
    const fpsChip = document.getElementById("fpsChip");
    const stateChip = document.getElementById("stateChip");

    const menu = document.getElementById("menu");
    const resumeBtn = document.getElementById("resumeBtn");
    const resetBtn = document.getElementById("resetBtn");
    const leaveBtn = document.getElementById("leaveBtn");

    const mm = document.getElementById("mm");
    const mmCtx = mm.getContext("2d");
    const mmPos = document.getElementById("mmPos");
    const mmNear = document.getElementById("mmNear");

    const coarse = matchMedia && matchMedia("(pointer: coarse)").matches;
    const reduce = matchMedia && matchMedia("(prefers-reduced-motion: reduce)").matches;
    const mobile = coarse || innerWidth < 820;

    const joy = document.getElementById("joy");
    const joyKnob = document.getElementById("joyKnob");
    const useBtn = document.getElementById("useBtn");
    document.getElementById("mobileUI").style.display = mobile ? "flex" : "none";

    // ===== Quality =====
    const QUALITY = {
      ultra: !mobile && !reduce,
      set(v){
        this.ultra = v;
        qualityBtn.setAttribute("aria-pressed", String(v));
        qualityBtn.textContent = `Quality: ${v ? "Ultra" : "Lite"}`;
        renderer.setPixelRatio(Math.min(devicePixelRatio || 1, v ? 2 : 1.25));
        fogNear = v ? 28 : 18;
        fogFar  = v ? 92 : 60;
        scene.fog.near = fogNear;
        scene.fog.far  = fogFar;
        fireflyTarget = v ? 220 : 120;
        ensureFireflies();
        swayEvery = v ? 2 : 4;
      }
    };

    // ===== World bounds =====
    const BOUNDS = { minX:-55, maxX:55, minZ:-92, maxZ:26 };

    // ===== Noise =====
    function hash2(x,z){
      let n = x * 374761393 + z * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      n = (n ^ (n >> 16));
      return (n >>> 0) / 4294967295;
    }
    function smoothstep(t){ return t*t*(3-2*t); }
    function valueNoise(x,z){
      const xi = Math.floor(x), zi = Math.floor(z);
      const xf = x - xi, zf = z - zi;
      const a = hash2(xi,zi), b = hash2(xi+1,zi), c = hash2(xi,zi+1), d = hash2(xi+1,zi+1);
      const u = smoothstep(xf), v = smoothstep(zf);
      const ab = a + (b-a)*u;
      const cd = c + (d-c)*u;
      return ab + (cd-ab)*v;
    }
    function fbm(x,z){
      let f=0, amp=1, freq=0.04;
      for(let i=0;i<5;i++){
        f += (valueNoise(x*freq, z*freq)-0.5)*2 * amp;
        amp *= 0.55;
        freq *= 2.0;
      }
      return f;
    }
    function heightAt(x,z){
      const base = fbm(x,z);
      const r = Math.sqrt(x*x + (z+18)*(z+18));
      const clearing = Math.max(0, 1 - (r/48));
      const flat = base * (1 - clearing*0.90);
      const micro = fbm(x*1.9, z*1.9) * 0.14;
      return flat*4.4 + micro;
    }

    // ===== Three.js =====
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio || 1, QUALITY.ultra ? 2 : 1.25));
    renderer.setClearColor(0x020302, 1);

    const scene = new THREE.Scene();
    let fogNear = QUALITY.ultra ? 28 : 18;
    let fogFar  = QUALITY.ultra ? 92 : 60;
    scene.fog = new THREE.Fog(0x050705, fogNear, fogFar);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.08, 400);
    camera.position.set(0, 2.2, 0);

    const controls = new PointerLockControls(camera, document.body);
    const clock = new THREE.Clock();

    // Lights
    const hemi = new THREE.HemisphereLight(0xbfe7c0, 0x0b0d0b, 0.78);
    scene.add(hemi);

    const sun = new THREE.DirectionalLight(0xffffff, 0.72);
    sun.position.set(-12, 18, 12);
    scene.add(sun);

    // ===== CINEMA SKY: forest.mp4 on dome =====
    const skyVideo = document.createElement("video");
    skyVideo.src = "assets/forest.mp4";
    skyVideo.loop = true;
    skyVideo.muted = true;
    skyVideo.playsInline = true;
    skyVideo.preload = "auto";

    const skyTex = new THREE.VideoTexture(skyVideo);
    skyTex.colorSpace = THREE.SRGBColorSpace;
    skyTex.minFilter = THREE.LinearFilter;
    skyTex.magFilter = THREE.LinearFilter;

    const skyGeo = new THREE.SphereGeometry(220, 48, 32);
    const skyMat = new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide });
    const sky = new THREE.Mesh(skyGeo, skyMat);
    scene.add(sky);

    // tone it down so it doesn’t look like a VR “wrap”
    const skyGradeGeo = new THREE.SphereGeometry(218, 32, 20);
    const skyGradeMat = new THREE.MeshBasicMaterial({
      color: 0x050705,
      transparent: true,
      opacity: 0.38,
      side: THREE.BackSide
    });
    const skyGrade = new THREE.Mesh(skyGradeGeo, skyGradeMat);
    scene.add(skyGrade);

    // ===== Terrain =====
    const size = 180;
    const seg = QUALITY.ultra ? 240 : 150;
    const terrainGeo = new THREE.PlaneGeometry(size, size, seg, seg);
    terrainGeo.rotateX(-Math.PI/2);

    const pos = terrainGeo.attributes.position;
    const colors = [];
    for(let i=0;i<pos.count;i++){
      const x = pos.getX(i);
      const z = pos.getZ(i);
      const h = heightAt(x,z);
      pos.setY(i, h);

      const moss = THREE.MathUtils.clamp((h+2)/6, 0, 1);
      const shade = THREE.MathUtils.clamp(0.55 + moss*0.45, 0, 1);
      const g = 0.18 + shade*0.56;
      const r = 0.10 + shade*0.22;
      const b = 0.10 + shade*0.18;
      colors.push(r,g,b);
    }
    terrainGeo.setAttribute("color", new THREE.Float32BufferAttribute(colors,3));
    terrainGeo.computeVertexNormals();

    const terrainMat = new THREE.MeshStandardMaterial({
      vertexColors: true,
      roughness: 1.0,
      metalness: 0.0
    });
    const terrain = new THREE.Mesh(terrainGeo, terrainMat);
    scene.add(terrain);

    // ===== Trees (instanced) + WIND SWAY =====
    const treeCount = QUALITY.ultra ? 1500 : 820;
    const trunkGeo = new THREE.CylinderGeometry(0.10, 0.16, 2.2, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x2a1b12, roughness: 1.0 });
    const leafGeo = new THREE.ConeGeometry(0.9, 2.6, 7);
    const leafMat = new THREE.MeshStandardMaterial({ color: 0x0b2a12, roughness: 1.0 });

    const trunks = new THREE.InstancedMesh(trunkGeo, trunkMat, treeCount);
    const leaves = new THREE.InstancedMesh(leafGeo, leafMat, treeCount);

    const dummy = new THREE.Object3D();
    const baseTrunk = new Array(treeCount);
    const baseLeaf  = new Array(treeCount);

    const treeMeta = new Array(treeCount);
    const treeColliders = [];

    function inClearing(x,z){
      const r = Math.sqrt(x*x + (z+18)*(z+18));
      return r < 30;
    }

    let ti=0;
    while(ti<treeCount){
      const x = THREE.MathUtils.randFloatSpread(135);
      const z = THREE.MathUtils.randFloatSpread(135);
      if(inClearing(x,z)) continue;

      const y = heightAt(x,z);
      const s = THREE.MathUtils.randFloat(0.85, 1.70);
      const rot = THREE.MathUtils.randFloat(0, Math.PI*2);

      // trunk
      dummy.position.set(x, y+1.1*s, z);
      dummy.rotation.set(0, rot, 0);
      dummy.scale.set(s, s, s);
      dummy.updateMatrix();
      trunks.setMatrixAt(ti, dummy.matrix);
      baseTrunk[ti] = dummy.matrix.clone();

      // leaf
      dummy.position.set(x, y+2.55*s, z);
      dummy.rotation.set(0, rot, 0);
      dummy.scale.set(s, s, s);
      dummy.updateMatrix();
      leaves.setMatrixAt(ti, dummy.matrix);
      baseLeaf[ti] = dummy.matrix.clone();

      treeMeta[ti] = { x, z, s, rot, phase: (x*0.11 + z*0.07) };

      if(Math.abs(x) < 60 && z > -110 && z < 40){
        treeColliders.push({x, z, r: 0.65*s});
      }

      ti++;
    }
    scene.add(trunks, leaves);

    // ===== Totems: posters + aim-to-play VIDEO =====
    const loader = new THREE.TextureLoader();
    const totems = [];

    // Create hidden video elements for each pack (play only after user gesture)
    const packVideos = PACKS.map(p=>{
      const v = document.createElement("video");
      v.src = p.video;
      v.loop = true;
      v.muted = true;
      v.playsInline = true;
      v.preload = "auto";
      return v;
    });

    function makeTotemCard(p, i, x, z){
      const group = new THREE.Group();
      const y = heightAt(x,z);
      group.position.set(x, y+1.75, z);

      // frame
      const frameGeo = new THREE.BoxGeometry(2.05, 2.9, 0.12);
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x0c0f0c, roughness: 0.55 });
      const frame = new THREE.Mesh(frameGeo, frameMat);
      group.add(frame);

      // poster texture
      const posterTex = loader.load(p.poster);
      posterTex.colorSpace = THREE.SRGBColorSpace;

      // video texture
      const vTex = new THREE.VideoTexture(packVideos[i]);
      vTex.colorSpace = THREE.SRGBColorSpace;
      vTex.minFilter = THREE.LinearFilter;
      vTex.magFilter = THREE.LinearFilter;

      // screen
      const screenGeo = new THREE.PlaneGeometry(1.78, 2.50);
      const screenMat = new THREE.MeshStandardMaterial({
        map: posterTex,
        roughness: 0.85,
        emissive: new THREE.Color(0x0c1a0c),
        emissiveIntensity: 0.38
      });
      const screen = new THREE.Mesh(screenGeo, screenMat);
      screen.position.set(0, 0, 0.065);
      group.add(screen);

      // glow ring
      const ring = new THREE.Mesh(
        new THREE.TorusGeometry(0.32, 0.06, 10, 22),
        new THREE.MeshBasicMaterial({ color: 0xcfff8c })
      );
      ring.position.set(-0.70, 1.10, 0.09);
      group.add(ring);

      // title plate (cheap but nice)
      const plate = new THREE.Mesh(
        new THREE.PlaneGeometry(2.22, 0.62),
        new THREE.MeshBasicMaterial({ color: 0x0a0f0a, transparent:true, opacity:0.55 })
      );
      plate.position.set(0, -1.75, 0.07);
      group.add(plate);

      totems.push({
        p, i, x, z,
        group, screen, screenMat,
        posterTex, videoTex:vTex,
        ring
      });

      scene.add(group);
    }

    const totemPositions = [
      {x:-14, z:-26},
      {x: 14, z:-26},
      {x:-9,  z:-40},
      {x:  9, z:-40},
      {x:  0, z:-32}
    ];
    PACKS.forEach((p,i)=> makeTotemCard(p,i, totemPositions[i].x, totemPositions[i].z));

    // ===== Fireflies (3D sprites) =====
    let fireflyTarget = QUALITY.ultra ? 220 : 120;
    let fireflies = [];
    const flyGeo = new THREE.SphereGeometry(0.03, 8, 8);
    const flyMat = new THREE.MeshBasicMaterial({ color: 0xcfff8c });
    function ensureFireflies(){
      while(fireflies.length < fireflyTarget){
        const m = new THREE.Mesh(flyGeo, flyMat);
        const x = THREE.MathUtils.randFloat(BOUNDS.minX, BOUNDS.maxX);
        const z = THREE.MathUtils.randFloat(BOUNDS.minZ, BOUNDS.maxZ);
        const y = heightAt(x,z) + THREE.MathUtils.randFloat(0.8, 3.8);
        m.position.set(x,y,z);
        m.userData = {
          phase: Math.random()*1000,
          base: m.position.clone(),
          speed: THREE.MathUtils.randFloat(0.4, 0.9),
          amp: THREE.MathUtils.randFloat(0.18, 0.55)
        };
        scene.add(m);
        fireflies.push(m);
      }
      while(fireflies.length > fireflyTarget){
        const m = fireflies.pop();
        scene.remove(m);
      }
    }
    ensureFireflies();

    // ===== Controls =====
    const keys = {w:false,a:false,s:false,d:false,q:false,e:false,shift:false};
    addEventListener("keydown",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=true;
      if(k==="a") keys.a=true;
      if(k==="s") keys.s=true;
      if(k==="d") keys.d=true;
      if(k==="q") keys.q=true;
      if(k==="e") keys.e=true;
      if(k==="shift") keys.shift=true;

      if(k==="f") tryEnterFocused();
      if(k==="escape") openMenu();
      if(k==="r") resetPosition();
    });
    addEventListener("keyup",(ev)=>{
      const k = ev.key.toLowerCase();
      if(k==="w") keys.w=false;
      if(k==="a") keys.a=false;
      if(k==="s") keys.s=false;
      if(k==="d") keys.d=false;
      if(k==="q") keys.q=false;
      if(k==="e") keys.e=false;
      if(k==="shift") keys.shift=false;
    });

    // Mobile joystick + look
    const joyState = {active:false,id:null,cx:0,cy:0,dx:0,dy:0};
    if(joy){
      joy.addEventListener("pointerdown",(e)=>{
        joyState.active=true; joyState.id=e.pointerId;
        joy.setPointerCapture(e.pointerId);
        const r=joy.getBoundingClientRect();
        joyState.cx=r.left+r.width/2; joyState.cy=r.top+r.height/2;
      });
      joy.addEventListener("pointermove",(e)=>{
        if(!joyState.active || e.pointerId!==joyState.id) return;
        const max=46;
        let dx=e.clientX-joyState.cx, dy=e.clientY-joyState.cy;
        const len=Math.hypot(dx,dy)||1;
        if(len>max){ dx=dx/len*max; dy=dy/len*max; }
        joyState.dx=dx/max; joyState.dy=dy/max;
        joyKnob.style.transform=`translate(${dx}px,${dy}px) translate(-50%,-50%)`;
      });
      const end=()=>{
        joyState.active=false; joyState.dx=0; joyState.dy=0;
        joyKnob.style.transform="translate(-50%,-50%)";
      };
      joy.addEventListener("pointerup",end);
      joy.addEventListener("pointercancel",end);
    }

    let look = {on:false,x:0,y:0};
    addEventListener("pointerdown",(e)=>{
      if(!mobile) return;
      if(e.target===joy || e.target===joyKnob || e.target===useBtn) return;
      look.on=true; look.x=e.clientX; look.y=e.clientY;
    },{passive:true});
    addEventListener("pointermove",(e)=>{
      if(!mobile || !look.on) return;
      const dx=e.clientX-look.x, dy=e.clientY-look.y;
      look.x=e.clientX; look.y=e.clientY;
      camera.rotation.y -= dx*0.0030;
      camera.rotation.x -= dy*0.0020;
      camera.rotation.x = THREE.MathUtils.clamp(camera.rotation.x, -0.75, 0.55);
    },{passive:true});
    addEventListener("pointerup",()=>{ look.on=false; },{passive:true});
    useBtn.addEventListener("click", tryEnterFocused);

    // Pointer lock + first user gesture = start videos
    addEventListener("click",(e)=>{
      const t=e.target;
      if(t.closest && (t.closest("#topbar") || t.closest("#dock") || t.closest("#minimapHUD") || t.closest("#menu") || t.closest("#mobileUI"))) return;
      if(!mobile) controls.lock();
      startAllVideosOnce();
    });

    let startedMedia = false;
    function startAllVideosOnce(){
      if(startedMedia) return;
      startedMedia = true;
      skyVideo.play().catch(()=>{});
      for(const v of packVideos) v.play().catch(()=>{});
    }

    controls.addEventListener("lock", ()=> stateChip.textContent = "WASD • Q/E • F");
    controls.addEventListener("unlock", ()=> stateChip.textContent = "Click to lock");

    // Menu
    function openMenu(){
      menu.style.display="flex";
      try{ controls.unlock(); }catch{}
    }
    function closeMenu(){
      menu.style.display="none";
      if(!mobile) controls.lock();
    }
    exitBtn.addEventListener("click", openMenu);
    resumeBtn.addEventListener("click", closeMenu);

    leaveBtn.addEventListener("click", ()=>{ location.href="shop.html"; });
    resetBtn.addEventListener("click", ()=>{ resetPosition(); closeMenu(); });

    // ===== Focus (raycast) =====
    const raycaster = new THREE.Raycaster();
    let focused = -1;

    function updateFocus(){
      focused = -1;
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const objects = totems.map(t=>t.screen);
      const hits = raycaster.intersectObjects(objects, false);
      if(hits.length){
        const hit = hits[0].object;
        const idx = objects.indexOf(hit);
        if(idx >= 0) focused = idx;
      }
    }

    function tryEnterFocused(){
      if(focused < 0) return;
      const t = totems[focused];
      const d = Math.hypot(camera.position.x - t.x, camera.position.z - t.z);
      if(d < 4.4){
        location.href = t.p.page;
      } else {
        dockSub.textContent = `Walk closer (${d.toFixed(1)}m)`;
      }
    }

    // ===== Movement + physics =====
    const dir = new THREE.Vector3();


    function clampBounds(pos){
      pos.x = THREE.MathUtils.clamp(pos.x, BOUNDS.minX, BOUNDS.maxX);
      pos.z = THREE.MathUtils.clamp(pos.z, BOUNDS.minZ, BOUNDS.maxZ);
    }
    function resolveTreeCollisions(pos){
      for(let i=0;i<treeColliders.length;i++){
        const c = treeColliders[i];
        const dx = pos.x - c.x;
        const dz = pos.z - c.z;
        const d = Math.hypot(dx,dz);
        if(d > 0.0001 && d < c.r){
          const push = (c.r - d);
          pos.x += (dx / d) * push;
          pos.z += (dz / d) * push;
        }
      }
    }
    function snapToGround(pos){
      pos.y = heightAt(pos.x, pos.z) + 2.2;
    }

    // ===== Start =====
    function resetPosition(){
      camera.position.set(0, heightAt(0,0)+2.2, 0);
      dockTitle.textContent = "Forest Clearing";
      dockSub.textContent = "Find a totem.";
    }
    resetPosition();

    // ===== Minimap =====
    function mmWorldToMap(wx,wz){
      const nx = (wx - BOUNDS.minX) / (BOUNDS.maxX - BOUNDS.minX);
      const nz = (wz - BOUNDS.minZ) / (BOUNDS.maxZ - BOUNDS.minZ);
      return { x:nx, y:nz };
    }
    function mmRoundRect(ctx,x,y,w,h,r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function drawMinimap(){
      if(mobile) return;
      const W=mm.width, H=mm.height;
      mmCtx.clearRect(0,0,W,H);

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(0,0,0,0.35)";
      mmRoundRect(mmCtx,0,0,W,H,18); mmCtx.fill();

      mmCtx.globalAlpha=.45;
      mmCtx.strokeStyle="rgba(255,255,255,0.10)";
      mmCtx.lineWidth=1;
      for(let i=1;i<5;i++){
        const x=(W*i/5)|0, y=(H*i/5)|0;
        mmCtx.beginPath(); mmCtx.moveTo(x,10); mmCtx.lineTo(x,H-10); mmCtx.stroke();
        mmCtx.beginPath(); mmCtx.moveTo(10,y); mmCtx.lineTo(W-10,y); mmCtx.stroke();
      }

      mmCtx.globalAlpha=1;
      mmCtx.strokeStyle="rgba(255,255,255,0.18)";
      mmCtx.lineWidth=1;
      mmRoundRect(mmCtx,0.5,0.5,W-1,H-1,18); mmCtx.stroke();

      const pad=18;

      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const m=mmWorldToMap(t.x, t.z);
        const x=pad + m.x*(W-2*pad);
        const y=pad + m.y*(H-2*pad);
        const isFocus = (i===focused);

        mmCtx.globalAlpha=isFocus?1:0.85;
        mmCtx.beginPath();
        mmCtx.strokeStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.55)";
        mmCtx.lineWidth=isFocus?3:2;
        mmCtx.arc(x,y,8,0,Math.PI*2); mmCtx.stroke();

        mmCtx.beginPath();
        mmCtx.fillStyle=isFocus?"rgba(205,255,140,0.92)":"rgba(255,255,255,0.65)";
        mmCtx.arc(x,y,2.6,0,Math.PI*2); mmCtx.fill();
      }

      const mp=mmWorldToMap(camera.position.x, camera.position.z);
      const px=pad + mp.x*(W-2*pad);
      const py=pad + mp.y*(H-2*pad);

      mmCtx.globalAlpha=0.55;
      mmCtx.fillStyle="rgba(205,255,140,0.35)";
      mmCtx.beginPath(); mmCtx.arc(px,py,14,0,Math.PI*2); mmCtx.fill();

      mmCtx.globalAlpha=1;
      mmCtx.fillStyle="rgba(255,255,255,0.92)";
      mmCtx.beginPath(); mmCtx.arc(px,py,4.2,0,Math.PI*2); mmCtx.fill();

      const ang = camera.rotation.y - Math.PI/2;
      mmCtx.strokeStyle="rgba(255,255,255,0.80)";
      mmCtx.lineWidth=2;
      mmCtx.beginPath();
      mmCtx.moveTo(px,py);
      mmCtx.lineTo(px + Math.cos(ang)*18, py + Math.sin(ang)*18);
      mmCtx.stroke();

      mmPos.textContent = `x ${camera.position.x.toFixed(1)} • z ${camera.position.z.toFixed(1)}`;

      let best={i:-1,d:1e9};
      for(let i=0;i<totems.length;i++){
        const t=totems[i];
        const d=Math.hypot(t.x-camera.position.x, t.z-camera.position.z);
        if(d<best.d) best={i,d};
      }
      mmNear.textContent = best.i>=0 ? `Nearest: ${PACKS[best.i].name} (${best.d.toFixed(1)}m)` : "Nearest: —";
    }

    // ===== Billboard + aim-to-play video =====
    function updateTotems(time){
      for(let i=0;i<totems.length;i++){
        const t = totems[i];

        // face you (billboard)
        t.group.lookAt(camera.position.x, t.group.position.y, camera.position.z);

        // subtle ring pulse on focus
        const pulse = 0.5 + 0.5*Math.sin(time*0.002 + i);
        t.ring.scale.setScalar(1 + pulse*0.10);

        // aim-to-play: swap texture map on focus
        if(i === focused){
          if(t.screenMat.map !== t.videoTex){
            t.screenMat.map = t.videoTex;
            t.screenMat.needsUpdate = true;
          }
          t.screenMat.emissiveIntensity = 0.55;
        }else{
          if(t.screenMat.map !== t.posterTex){
            t.screenMat.map = t.posterTex;
            t.screenMat.needsUpdate = true;
          }
          t.screenMat.emissiveIntensity = 0.35;
        }
      }
    }

    // ===== Tree sway (cheap, looks good) =====
    let swayEvery = QUALITY.ultra ? 2 : 4;
    const m4 = new THREE.Matrix4();
    const q = new THREE.Quaternion();
    const v3 = new THREE.Vector3();
    const s3 = new THREE.Vector3();
    function swayTrees(time, frame){
      if(frame % swayEvery !== 0) return;

      // sway only a subset each update to keep FPS nice
      const step = QUALITY.ultra ? 3 : 5;

      for(let i=0;i<treeCount;i+=step){
        const meta = treeMeta[i];
        if(!meta) continue;

        // sway depends on position
        const w = Math.sin(time*0.0012 + meta.phase) * 0.03;
        const w2 = Math.cos(time*0.0010 + meta.phase*1.3) * 0.02;
        const rotY = meta.rot + w2;

        // trunk: tiny rotation
        q.setFromEuler(new THREE.Euler(w*0.25, rotY, 0));
        v3.set(meta.x, heightAt(meta.x, meta.z)+1.1*meta.s, meta.z);
        s3.set(meta.s, meta.s, meta.s);

        m4.compose(v3, q, s3);
        trunks.setMatrixAt(i, m4);

        // leaves: bigger sway
        q.setFromEuler(new THREE.Euler(w*0.9, rotY, w*0.35));
        v3.set(meta.x, heightAt(meta.x, meta.z)+2.55*meta.s, meta.z);
        m4.compose(v3, q, s3);
        leaves.setMatrixAt(i, m4);
      }

      trunks.instanceMatrix.needsUpdate = true;
      leaves.instanceMatrix.needsUpdate = true;
    }

    // ===== Fireflies movement =====
    function animateFireflies(time){
      for(const f of fireflies){
        const d = f.userData;
        d.phase += d.speed * 0.016;
        f.position.x = d.base.x + Math.sin(d.phase + time*0.0005)*d.amp*2.2;
        f.position.z = d.base.z + Math.cos(d.phase + time*0.00045)*d.amp*2.0;
        f.position.y = heightAt(f.position.x, f.position.z) + 1.1 + (0.6 + Math.sin(d.phase*1.3)*0.5);
      }
    }

    // ===== Movement loop =====
    const up = new THREE.Vector3(0,1,0);
    const forward = new THREE.Vector3();
    const right = new THREE.Vector3();

    function clampBounds(pos){
      pos.x = THREE.MathUtils.clamp(pos.x, BOUNDS.minX, BOUNDS.maxX);
      pos.z = THREE.MathUtils.clamp(pos.z, BOUNDS.minZ, BOUNDS.maxZ);
    }
    function resolveTreeCollisions(pos){
      for(let i=0;i<treeColliders.length;i++){
        const c = treeColliders[i];
        const dx = pos.x - c.x;
        const dz = pos.z - c.z;
        const d = Math.hypot(dx,dz);
        if(d > 0.0001 && d < c.r){
          const push = (c.r - d);
          pos.x += (dx / d) * push;
          pos.z += (dz / d) * push;
        }
      }
    }
    function snapToGround(pos){
      pos.y = heightAt(pos.x, pos.z) + 2.2;
    }

    // ===== Resize =====
    addEventListener("resize", ()=>{
      renderer.setSize(innerWidth, innerHeight);
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
    }, {passive:true});

    // Quality toggle
    qualityBtn.addEventListener("click", ()=> QUALITY.set(!QUALITY.ultra));
    QUALITY.set(QUALITY.ultra);

    // ===== Main loop =====
    let frames=0, fpsLast=performance.now(), frame=0;

    function animate(time){
      requestAnimationFrame(animate);
      frame++;

      const dt = Math.min(0.033, clock.getDelta());

      // Q/E turn
      if(keys.q) camera.rotation.y += 1.25 * dt;
      if(keys.e) camera.rotation.y -= 1.25 * dt;

      dir.set(0,0,0);
      const sp = (keys.shift ? 6.2 : 4.7) * (mobile ? 0.85 : 1);
      if(keys.w) dir.z -= 1;
      if(keys.s) dir.z += 1;
      if(keys.a) dir.x -= 1;
      if(keys.d) dir.x += 1;
      if(mobile){ dir.x += joyState.dx; dir.z += joyState.dy; }
      if(dir.lengthSq() > 0) dir.normalize();

      camera.getWorldDirection(forward);
      forward.y = 0; forward.normalize();
      right.crossVectors(forward, up).normalize().negate();

      const move = new THREE.Vector3()
        .addScaledVector(forward, dir.z)
        .addScaledVector(right, dir.x);

      camera.position.addScaledVector(move, sp * dt);

      clampBounds(camera.position);
      resolveTreeCollisions(camera.position);
      snapToGround(camera.position);

      // Keep sky centred + subtle drift so it feels alive
      sky.position.copy(camera.position);
      sky.rotation.y += 0.0002;

      // Focus
      updateFocus();

      // Dock text
      if(focused >= 0){
        dockTitle.textContent = PACKS[focused].name;
        const t = totems[focused];
        const d = Math.hypot(camera.position.x - t.x, camera.position.z - t.z);
        dockSub.textContent = d < 4.4 ? "Press F to enter" : `Walk closer (${d.toFixed(1)}m)`;
      } else {
        dockTitle.textContent = "Forest Clearing";
        dockSub.textContent = "Find a totem.";
      }

      // Totems
      updateTotems(time);

      // Atmosphere
      animateFireflies(time);
      swayTrees(time, frame);

      // Render
      renderer.render(scene, camera);

      // Minimap
      drawMinimap();

      // FPS
      frames++;
      const now=performance.now();
      if(now - fpsLast > 500){
        fpsChip.textContent = `FPS: ${Math.round(frames*1000/(now-fpsLast))}`;
        frames=0; fpsLast=now;
      }
    }

    // ===== Pointer lock events =====
    controls.addEventListener("lock", ()=> stateChip.textContent = "WASD • Q/E • F");
    controls.addEventListener("unlock", ()=> stateChip.textContent = "Click to lock");

    // ===== Menu =====
    function openMenu(){
      menu.style.display="flex";
      try{ controls.unlock(); }catch{}
    }
    function closeMenu(){
      menu.style.display="none";
      if(!mobile) controls.lock();
    }
    exitBtn.addEventListener("click", openMenu);
    resumeBtn.addEventListener("click", closeMenu);
    resetBtn.addEventListener("click", ()=>{ resetPosition(); closeMenu(); });
    leaveBtn.addEventListener("click", ()=>{ location.href="shop.html"; });

    // Start loop
    animate(performance.now());
  </script>
</body>
</html>
